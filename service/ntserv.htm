<html>

<head>
<title>CNTService v1.57</title>
<link rel="stylesheet" type="text/css" href="naughter.css">
</head>

<body>

<h2 align="left"><img src="serv.gif" width="44" height="36"><strong>CNTService
v1.57</strong></h2>

<p>Welcome to <strong>CNTService</strong>, a collection of freeware MFC
classes which provide a class framework for developing NT services in MFC. </p>

<p>For detailed information about NT services, how to develop them and
their relationship to other NT subsystems, I would suggest you thoroughly read the
relevant documentation which comes with the Platform SDK.</p>

<p>&nbsp;</p>

<table width="240">
  <tr>
    <td width="236"><a href="#Features">Features</a></td>
  </tr>
  <tr>
    <td width="236"><a href="#Usage">Usage</a></td>
  </tr>
  <tr>
    <td width="236"><a href="#Copyright">Copyright</a></td>
  </tr>
  <tr>
    <td width="236"><a href="#History">History</a></td>
  </tr>
  <tr>
    <td width="236"><a href="#APIReference">Class Framework Reference</a></td>
  </tr>
  <tr>
    <td width="236"><a href="#Enhancements">Planned Enhancements</a></td>
  </tr>
  <tr>
    <td width="236"><a href="#References">References</a></td>
  </tr>
  <tr>
    <td width="236"><a href="#Contact">Contacting the Author</a></td>
  </tr>
</table>

<p>&nbsp;</p>

<h2><a name="Features"></a><strong>Features</strong>

</h2>

<ul>
  <li>Simple and clean C++ interface using virtual
    functions.</li>
  <li>All the code is Unicode enabled and build configurations are
    provided.</li>
  <li>All code compiles cleanly at the highest warning level of 4. This is
    the case with all of my other code on my web site as well.</li>
  <li>Build in persistence functions which provide
    support similar to the build in MFC registry / ini functions.</li>
  <li>A simple test service has been provided to
    help you get started developing your own NT services.</li>
</ul>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h2><a name="Usage"></a><strong>Usage</strong>

</h2>

<ul>
  <li>Bear in mind that these classes are very NT
    specific and none of this code will work correctly on 95, 98 or ME. Both of these operating
    systems do provide some support for services but in a completely incompatible manner with
    NT services.</li>
  <li>To use the classes in your code simple
    include ntserv*.cpp in your project and #include ntserv.h in which ever of your modules
    needs to make calls to the class and derive your own service class from CNTService and
    override the necessary functions.</li>
  <li>You should also copy across
    the &quot;IDS_NTSERV...&quot; string resources from the sample project into
    your service's project.</li>
  <li>You can optionally also develop a simple DLL of the same
    name as your service which includes just the MC resources. See the &quot;OcsServiceMsg&quot;
    subproject in the sample for how this works.
    For
    further information on this check on the history details for v1.06 and v1.08
    below.</li>
  <li>To see the class in action, have a look at the code in InitInstance
    in the module &quot;app.cpp&quot;. </li>
  <li>Your code will need to include MFC either statically or dynamically.</li>
</ul>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h2><b><a name="Copyright"></a>Copyright</b></h2>
<p>You are allowed to include the source code in any product
(commercial, shareware, freeware or otherwise) when your product is released in
binary form. You are allowed to modify the source code in any way you want
except you cannot modify the copyright details at the top of each module. If you
want to distribute source code with your application, then you are only allowed
to distribute versions released by the author. This is to maintain a single
distribution point for the source code.&nbsp;</p>
<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h2><a name="History"></a><strong>History</strong></h2>

<p><strong>V1.0 (17 July 1998)</strong> 

<ul>
  <li>Initial public release.</li>
</ul>

<p><strong>24 August 1998</strong> 

<ul>
  <li>Minor update to the demo program (app.cpp)
    to get rid of a compiler error.</li>
</ul>

<p><strong>V1.01 (17 May 1999)</strong>

<ul>
  <li>Addition of a number of ASSERT's statements to aid in debugging.
  </li>
  <li>Fixed a bug in CNTEventLogSource::Report as reported by Marin Kunev</li>
  <li>Fixed a compiler warning when compiled with VC 6.</li>
</ul>

<p><strong>V1.02 (5 September 1999)</strong>

<ul>
  <li>Addition of more ASSERT's statements to aid in debugging. </li>
</ul>

<p><strong>V1.03 (3 October 1999)</strong>

<ul>
  <li>Addition of GetProfileStringArray, WriteProfileStringArray,
    GetProfileBinary and WriteProfileBinary methods to the CNTService class.</li>
  <li>Renamed some module names.</li>
</ul>

<p><strong>V1.04 (5 October 1999)</strong>

<ul>
  <li>Fixed a problem compiling the mc file for release and
    Unicode build configurations.</li>
  <li>Fixed a level 4 warning when built using VC++ 6.</li>
</ul>

<p><strong>V1.05 (10 October 1999)</strong>

<ul>
  <li>Added support for the description field which services can
    have on Windows 2000.</li>
  <li>Added accessor functions for the service name, friendly name
    and the description text.</li>
</ul>

<p><strong>V1.06 (24 January 2000)</strong>

<ul>
  <li>Modified the way the mc file is included into the
    OcsService.exe sample service. The mc file is now compiled into an intermediate
    &quot;ntserv_msg.rc&quot; file which is &quot;#included&quot; into the final
    rc file &quot;OcsService.rc&quot;. This is done so that the &quot;testsrc.rc&quot;
    file can be edited by the resource designer inside Visual C++. In previous
    versions of CNTService, if your tried to edit the rc file (which was
    generated by the MC command line compiler), you would end up corrupting the
    file. If you are developing your own service using CNTService, then I would
    suggest you take this approach. What you need to do is create a resource
    script inside VC++, adding whatever resources you want to be in your
    services resources (e.g. version info's, strings etc), then bring up the
    resource includes dialog and modify the &quot;Compile-Time directives&quot;
    to &quot;#include &quot;ntserv_msg.rc&quot; or your version of rc file which
    was generated by MC by compiling your .mc file. You should also check out
    the project settings in the demo service provided with CNTService to see how
    it handles compilation of the .mc file via a batch file (right mouse click
    on &quot;ntserv_msg.mc&quot; and select settings).&nbsp;</li>
</ul>

<p><strong>V1.07 (10 April 2000)</strong>

<ul>
  <li>Fixed a bug with the calculation of buffer sizes when compiled
    for UNICODE in CNTEventLogSource::SetStringArrayIntoRegistry</li>
</ul>

<p><strong>V1.1 (21 May 2000)</strong>

<ul>
  <li> Added 2 new overridden versions of CNTEventLogSource::Report</li>
  <li>Tweaked and set default parameters in CNTService::ReportStatusToSCM
    following review of the book "Professional NT Services"</li>
  <li>Disallowed accepting any controls when the service is currently                          processing the same control in ReportStatusToSCM</li>
  <li>Change the ordering of parameters in ReportStatusToSCM. You should review                          your code to ensure it is correct if you have existing code</li>
  <li>Class framework now by default uses a DLL of the same name for
    the message file which the NT Event log will look to for mc string entries. This means that you should review your code to ensure it is correct if you                          have existing code</li>
  <li>CNTEventLogSource::Report now does not bother automatically creating
    a SID as this should be used for services which do impersonation for clients</li>
  <li>Changed the constructor of CNTEventLog which now takes
    the values it
    needs for calling Register</li>
  <li>CNTEventLog::Report methods are now no longer const because of change
    above.</li>
  <li>SCM database is now locked during installs and uninstalls of the service</li>
  <li>Now supports all the new functionality provided for services under Windows 2000
    while preserving binary compatibility with NT 3.x and NT 4 services.</li>
  <li>Framework now requires the presence of the January 2000 platform
    SDK or later.
    This is because of point above.</li>
  <li>Changed the prototype of the existing CNTScmService::QueryStatus function.&nbsp;</li>
  <li>Made the typedefs for the enumeration functions private to their respective
    classes instead of polluting the global name space</li>
</ul>

<p><strong>V1.11 (19 June 2000)</strong>

<ul>
  <li> Added an ASSERT to ReportStatusToSCM for status handle == 0</li>
  <li>Fixed a number of other logic problems in ReportStatusToSCM</li>
  <li>Removed an unnecessary ASSERT in CNTEventLogSource::Report</li>
  <li>Sample service app now uses sound card default sound instead of PC speaker sound</li>
</ul>

<p><strong>V1.12 (21 June 2000)</strong>

<ul>
  <li> Minor change to a TRACE statement in RegisterCtrlHandler</li>
  <li>RegisterCtrlHandler is called automatically for you now, no need to call it in
    your derived version of ServiceMain</li>
  <li>Added a BOOL CNTEventLogSource::Report(WORD wType, LPCTSTR lspszString) method</li>
  <li>Fixed a bug where the sample service was not reporting its shutdown status to                          the SCM correctly.</li>
</ul>

<p><strong>V1.13 (28 July 2000)</strong>

<ul>
  <li>Fixed a project settings bug which was causing the
    following compiler error <i>&quot;fatal error C1083: Cannot open include file: 'ntserv_msg.h': No such file or directory&quot;</i>.&nbsp;</li>
</ul>

<p><strong>V1.14 (21 December 2000)</strong>

<ul>
  <li>Fixed a bug in CNTService::Uninstall() which was causing it to fail sometimes
    when the service was running.</li>
  <li>Made all the member variables of the CNTService class public but put them down below
    the &quot;implementation&quot; line ala the way standard MFC classes are declared.</li>
  <li>Added a new overridden version of CNTEventLogSource::Report.</li>
</ul>

<p><strong>V1.15 (8 January 2001)</strong>

<ul>
  <li> Now includes copyright message in the source code and documentation.</li>
  <li> CNTEventLogSource::Report now allows you to specify whether error codes should be
    displayed in Hex or as decimal</li>
  <li>Sample service sometimes did not display the stop event. This has been remedied by
    reporting to the event log before we report to the SCM.</li>
  <li>Framework has now been made independent of the need for the latest Platform SDK
    header files. You can now compile the code in VC 5 without the Platform SDK having to
    be installed.</li>
</ul>

<p><strong>V1.16 (16 May 2001)</strong>

<ul>
  <li>Thread protected code to CNTEventLogSource::Report.</li>
</ul>

<p><strong>V1.17 (27 May 2001)</strong>

<ul>
  <li>Added methods to framework to support the new command line options -start, -pause,                          -continue and -stop. Thanks to Stefan Niemeyer for this great addition.</li>
  <li>Fixed a small issue in the testing of the CEventLogSource class in app.cpp.</li>
</ul>

<p><strong>V1.18 (15 July 2001)</strong>

<ul>
  <li> Fixed a problem when calling CreateService with pathnames which contain embedded spaces.</li>
</ul>

<p><strong>V1.19 (18 July 2001)</strong>

<ul>
  <li>Minor update to the sample code demonstrating the class
    framework.</li>
  <li>Due to VC 6 shipping with a Winsvc.h (The main NT service header file) which includes
    some but not all of the defines which the class requires you need to define a few preprocessor
    define to get the code to compile cleanly for your particular setup. Set the
    top of &quot;ntserv.cpp&quot; for the details.</li>
</ul>

<p><strong>V1.20 (9 August 2001)</strong>

<ul>
  <li> Updated SetStringArrayIntoRegistry and GetStringArrayIntoRegistry to be consistent with                          my other class CHKLM v1.11.</li>
</ul>

<p><b>v1.21 (27 November 2001)</b></p>

<ul>
  <li> Fixed an issue where the class fails to read any key that is 
  read-only.                          This is a problem since Win2000 defaults access to HKLM for "normal"&nbsp;
    users to read-only. Thanks to Hans-Georg Ulrich for spotting this problem.</li>
</ul>

<p><b>v1.22 (27 August 2002)</b></p>

<ul>
  <li> Made more functions virtual to allow greater end user customisation.</li>
  <li>All useful attributes in call to CreateService in CNTService::Install can now be 
  modified without having
    to derive a custom version of CNTService::Install in your derived class.</li>
  <li>A boolean value is now provided to enable / disable event log integration</li>
</ul>

<p><b>v1.23 (28 August 2002)</b></p>

<ul>
  <li> Reviewed all TRACE statements in the code for correctness</li>
  <li>Added a parameter to CNTService::Install to allow the time to wait for the service to stop to be specified</li>
  <li>Added a CString parameter to the CNTService::Install and Uninstall methods to return a descriptive
    errors to callers.</li>
  <li>Addition of a new boolean variable to the CNTService
    class&nbsp; to allow service to decide whether it                          should use GUI or Console calls to display status messages</li>
  <li>CNTService::ProcessShellCommand now displays error messages to the console or via a Message box when errors
    occur in install, uninstalling, starting, stopping, resuming and pausing the service.</li>
</ul>

<p><b>v1.24 (20 September 2002)</b></p>

<ul>
  <li> Fixed an "issue" in calls to ReportStatusToSCM which your service should be calling in your ServiceMain. Specifically
    calling ReportStatusToSCM(SERVICE_STOPPED) looks like it elicits the behaviour that the SCM forcefully terminates your
    worker thread. This can cause issues when other code is executed after this call which uses something which is allocated
    on the worker threads stack. To fix this "issue" (I could not find any documentation on this behaviour) you should remove
    the single call to ReportStatusToSCM which uses the values "SERVICE_STOPPED" from the bottom of your service's ServiceMain
    function. To force you to do this, I have changed the name of the function "ReportStatusToSCM" to just "ReportStatus". This
    will mean that the compiler will force you to examine each call to this function and remove the one call as described above.
    The class framework now looks after reporting that your service has stopped to the
    SCM. Thanks to &quot;Jim&quot; for spotting this.</li>
</ul>

<p><b>v1.25 (20 November 2002)</b></p>

<ul>
  <li> Fixed 3 level 4 warnings when the code is compiled using VC.Net. Thanks to Ed Eichman for spotting this problem.</li>
</ul>

<p><b>v1.26 (12 March 2003)</b></p>

<ul>
  <li>Fixed a problem since user code can't call 
  ReportStatus(SERVICE_STOPPED) there is no way to report start-up or shutdown 
  errors via dwWin32ExitCode or dwServiceSpecificExitCode. This has been 
  resolved by adding a new protected function TerminateService to shut down the 
  service in the event of a critical failure. This throws a private exception 
  containing the exit codes which is caught by the framework in _ServiceMain (or 
  the DebugService case of ProcessShellCommand). _ServiceMain then passes the 
  codes on via _ReportStatus. Also since the dwWin32ExitCode and 
  dwServiceSpecificExitCode arguments of ReportStatus can never be used these 
  parameters have now been removed. Thanks to Jon Baggott for these 2 additions.</li>
  <li>Performed some minor tidy ups in the inclusion of 
  header files by the framework</li>
</ul>

<p><b>v1.27 (8 May 2003)</b></p>

<ul>
  <li>Update to the Install and Uninstall methods to return 
  the value from GetLastError(). This is useful for client code as it can be 
  reset before the functions return.</li>
  <li>Command line now supports a /T: param which allows you 
  to specify a timeout to use when doing an uninstall. This timeout is used to 
  specify how long the code will wait if the service needs to be stopped.</li>
  <li>Broke down all the classes into their own modules. This 
  allows you to pull in only the classes you require, if you are not using the 
  main class CNTService.</li>
  <li>Removed all unnecessary TRACE statements throughout the 
  framework as they sometimes reset the value as returned from GetLastError.</li>
</ul>

<p><b>v1.28 (17 May 2003)</b></p>

<ul>
  <li>Further tweaks to _ReportStatus to avoid intermittent 
  crashes. See item 1 on 20-09-2002 for detailed info about the issue.</li>
  <li>Removed some unnecessary calls to locking the critical 
  section</li>
</ul>

<p><b>v1.29 (22 May 2003)</b></p>

<ul>
  <li>Updated the way the sample service's message dll 
  projects integrates the creation of the mc file. For detailed information on 
  how to integrate mc files into Visual Studio, please see the CodeProject 
  article <a href="http://www.codeproject.com/useritems/MCTutorial.asp">http://www.codeproject.com/useritems/MCTutorial.asp</a>. Please note 
  that I did not follow the suggested settings as exactly outlined in this 
  article as the message file's header file needs to be included into the NT 
  service exe at compile time.</li>
</ul>

<p><b>v1.30 (3 August 2003)</b></p>

<ul>
  <li>Improved the error handling and reporting in 
  CNTService::SetServiceToStatus. Thanks to Jon Pawley for reporting this issue.</li>
</ul>

<p><b>v1.31 (15 August 2003)</b></p>

<ul>
  <li>Optimized the string copying in 
  CEventLogRecord::CEventLogRecord(const EVENTLOGRECORD* pRecord). A bug was 
  reported in this area by Jeroen Walter but it looks like this is a 
  documentation bug in current versions of the MSDN. This structure was defined 
  correctly in some early versions of the MSDN.</li>
</ul>

<p><b>v1.32 (8 September 2003)</b></p>

<ul>
  <li>Moved all the defines which the framework requires into 
  a separate header file. Thanks to Dima Polyakov for pointing out a compilation 
  problem which occurred when you did not have the platform SDK installed which 
  necessitated this change.</li>
  <li>Changed the ordering of the command line used to 
  compile the MC file. This avoids a problem as reported by Rodrigo Oliveira 
  Fernandez when using the framework in VC 7</li>
  <li>Fixed a compilation error related to the use of the 
  preprocessor define NTSERV_EXCLUDE_VC6_WINSVC_DEFINES</li>
</ul>

<p><b>v1.33 (4 October 2003)</b></p>

<ul>
  <li>Updated the custom build steps to compile the mc file. 
  Now uses the VC macro &quot;$(InputPath)&quot; instead of &quot;$(InputDir)\$(InputName).mc&quot;.</li>
  <li>Removed a number of unreferenced variables level 4 
  warnings when compiled with VC.Net 2003.</li>
  <li>Provision of a specific workspace (OcsService for Visual 
  Studio.Net.dsw) which allows the sample service to be compiled cleanly out of 
  the box with Visual Studio.Net 2000 or Visual Studio.Net 2003. The issue is 
  that the format of various build macros such as $(InputDir) has changed from 
  VC 6. Just select File -&gt; Open Project in VS.Net and select &quot;OcsService for 
  Visual Studio.Net.dsw&quot;.</li>
</ul>

<p><b>v1.34 (5 October 2003)</b></p>

<ul>
  <li>Updated the Visual Studio.Net workspace to remove the 
  &quot;Without Platform SDK&quot; configurations as they are not applicable.</li>
</ul>

<p><b>v1.35 (12 November 2003)</b></p>

<ul>
  <li>Now includes a unicode MC file thanks to Brodie 
  Thiesfield. To use this file, simply copy ntserv_msgU.mc over the 
  ntserv_msg.mc file in the OcsServiceMsg and modify the custom build step for the 
  mc file in the OcsServiceMsg project to include a -u command line option. This 
  file also includes a Japanese translation of the default service event log 
  strings which the sample service uses.</li>
</ul>

<p><b>v1.36 (14 November 2003)</b></p>

<ul>
  <li>The location where the message dll for the service is 
  located can now be tweaked at runtime by filling in the 
  CNTService::m_sMessageDll variable. Thanks to Brodie Thiesfield for this 
  update.</li>
  <li>Reviewed all TRACE statements which use a CString 
  parameter. Now explicitly casts the CString to a LPCTSTR. Thanks to Brodie 
  Thiesfield for this update.</li>
  <li>Added a new CNTService::m_LoggingDetail variable. This 
  in combination with a new method called CNTService::Win32ErrorToString allows 
  more flexible control over how errors are logging to the event log. Thanks to 
  Brodie Thiesfield for suggesting this update.</li>
  <li>command line arguments other than the &quot;-debug&quot; argument 
  are passed through to ServiceMain() when running in debug mode. Thanks to 
  Brodie Thiesfield for suggesting this update.</li>
</ul>

<p><b>v1.37 (19 November 2003)</b></p>

<ul>
  <li>Reworked the function Win32ErrorToString to include the 
  string resource ID. Thanks to Brodie Thiesfield for suggesting this. 
  </li>
  <li>Fixed CNTS_MSG_SERVICE_FAIL_PAUSE, 
  CNTS_MSG_SERVICE_FAIL_CONTINUE and CNTS_MSG_SERVICE_FAIL_STOP event log 
  entries which were not using the new Win32ErrorToString method. Thanks to 
  Brodie Thiesfield for reporting this.</li>
  <li>Win32ErrorToString now includes a &quot;bEventLog&quot; 
  parameter. When this is TRUE the function is being called to obtain the error 
  which gets displayed in the event log, when FALSE, it is being used to display 
  to the end user or the TRACE window</li>
</ul>

<p><b>v1.38 (23 November 2003)</b></p>

<ul>
  <li>Fixed a memory leak in CNTService::Debug when the 
  service uses TerminateService to shutdown the service prematurely.</li>
</ul>

<p><b>v1.39 (26 November 2003)</b></p>

<ul>
  <li>Now supports a /silent command line option. Using this 
  setting in combination with for example /install will ensure that the 
  framework does not display any message boxes or console output when an error 
  occurs. Thanks to Metrich Frederic for this addition.</li>
  <li>Changed the return value from ProcessShellCommand from 
  a BOOL to a DWORD. This value is now use to return an error code from the 
  service exe when it exits. In combination with the /silent command line 
  option, this allows third party programs such as installers control over the 
  service instance via the exit code of the service. Again thanks to Metrich 
  Frederic for this addition.</li>
  <li>Updated the sample app provided with the framework to 
  show how client services can return the Win32 error code as now returned by 
  ProcessShellCommand.</li>
</ul>

<p><b>13 January 2004</b></p>

<ul>
  <li>Updated the declaration of the sample service's &quot;m_bWantStop&quot; 
  variable to now be a variable. There is no change to the actual CNTService 
  modules (bar copyright updates for the new year 2004) </li>
</ul>

<p><b>v1.40 (22 January 2004)</b></p>

<ul>
  <li>Fixed a bug in CNTScmService::EnumDependents and 
  CNTServiceControlManager::EnumServices where enumeration would continue even 
  when the callback functions return FALSE. Thanks to Edward Livingston for 
  spotting this.</li>
</ul>

<p><b>21 February 2004</b></p>

<ul>
  <li>The Unicode version of the mc file has now been updated 
  to include Korean resources. Thanks to Brodie Thiesfield for this update.</li>
</ul>

<p><b>v1.41 (18 March 2004)</b></p>

<ul>
  <li>Fixed a bug in the CNTScmService::WaitForServiceStatus 
  function which caused it to return TRUE even if the service failed to return 
  the desired status (if pending status isn't the expected pending staus. 
  </li>
  <li>Also ensured that CNTScmService::WaitForServiceStatus 
  does not wait past the requested timeout period. Thanks to Brodie Thiesfield 
  for these bug reports and the fixes.</li>
</ul>

<p><b>v1.42 (9 April 2004)</b></p>

<ul>
  <li>Further work to CNTScmService::WaitForServiceStatus. It 
  now ignores pending states. In addition it ignores wait hints since we are 
  calling QueryServiceStatus as opposed to calling the ControlService function 
  with the SERVICE_CONTROL_INTERROGATE control code. It also allows the polling 
  interval to be specified by a 3rd optional parameter. Thanks to Edward 
  Livingston and &quot;yong&quot; for reporting this&nbsp;problem. Please note that since 
  the third parameter to this function means something different that 
  previously, you should review all of your calls to WaitForServiceStatus to 
  ensure it continues to operate correctly.</li>
</ul>

<p><b>v1.43 (12 April 2004)</b></p>

<ul>
  <li>Removed an unused variable in 
  CNTScmService::WaitForServiceStatus. Thanks to Edward Livingston for reporting 
  this issue.</li>
</ul>

<p><b>v1.44 (5 May 2004)</b></p>

<ul>
  <li>Fixed some warnings in CNTService::GetDependencies and 
  CNTEventLogSource::SetStringArrayIntoRegistry when the code is compiled using 
  the &quot;Force conformance in For loop scope&quot; VC compiler option (/Zc:forScope). 
  Thanks to Alexey Kuznetsov for reporting this problem.</li>
</ul>

<p><b>v1.45 (20 June 2004)</b></p>

<ul>
  <li>Fixed a bug in CEventLogRecord::CEventLogRecord(const 
  EVENTLOGRECORD*..) to do with the handling of inter string NULLs at the end of 
  the record. Thanks to &quot;yong&quot; for reporting this problem.</li>
  <li>Optimized the code in 
  CEventLogRecord::CEventLogRecord(const EVENTLOGRECORD*..).</li>
</ul>

<p><b>v1.46 (20 June 2004)</b></p>

<ul>
  <li>Provided a new virtual implementation of 
  CNTService::_ServiceMain. To achieve this the previous static _ServiceMain is 
  now called &quot;_SDKServiceMain&quot;. This allows your service code to completely 
  customize the startup of your service. For example if you service does not 
  require an active worker thread to do any work (e.g. it only ever responds to 
  client requests thro the SCM using OnUserDefinedRequest), then you could 
  implement your own version of _ServiceMain which does not call _ReportStatus(SERVICE_STOPPED... 
  This would allow you to use RegisterWaitForSingleObject to implement your 
  service clean up code. For more information on this type of service please 
  consult the MSDN documentation on &quot;RegisterWaitForSingleObject&quot; and &quot;ServiceMain&quot;. Thanks 
  to Haug Leuschner for reporting this.</li>
</ul>

<p><b>v1.47 (24 June 2004)</b></p>

<ul>
  <li>Reissue of the last update as I forgot to declare _ServiceMain 
  virtual, Doh!</li>
  <li>Also made the class CNTServiceTerminateException
    visible in the global namespace. This is required if you implement your own _ServiceMain.</li>
</ul>

<p><b>v1.48 (15 October 2004)</b></p>

<ul>
  <li> Framework now automatically installs a console ctrl handler when run in debug mode. This means that the framework will automatically
    call your service's OnStop method when running in debug mode if your service is built as a console app and you hit Ctrl+C or Ctrl+Break or
    hit the close button in the console window. This helps you to verify the shutdown code of your service without having to run the code as                          a service. Because the console ctrl handler is executed in a separate thread to ServiceMain, this simulation mode calls your OnStop method                          in a separate thread just like the SCM does. This proves very helpful when you need to debug shutdown problems in your service which are                          thread related.</li>
  <li>Added a few checks to various header files to warn if various header files have not already been included e.g. Afxmt.h. This helps avoid
    simple compilation problems when the framework is added to a new project initially.</li>
  <li>Sample app now uses the InterlockedExchange functions instead of a critical section to serialize access to variables used across multiple
    threads. In addition the "m_bPaused" variable of the sample app is now also marked as volatile</li>
  <li>Fixed a double declaration of "dwTypesSupported" in CNTEventLogSource::Install. In
    the process this fixes a level 4 warning which the                          code generated.</li>
</ul>

<p><b>v1.49 (18 October 2004)</b></p>

<ul>
  <li>Fixed a number of level 4 warnings in the framework when "Detect 64 bit portability issues" is enabled in Visual Studio .Net</li>
</ul>

<p><b>v1.50 (11 November 2004)</b></p>

<ul>
  <li>Fixed a futher 64 bit issue in CNTEventLogSource::SetStringArrayIntoRegistry when compiled in Visual Studio .Net.&nbsp;</li>
  <li>Addition of a CNTSERVICE_EXT_CLASS preprocessor macro which allows the classes to be easily added to an extension dll</li>
</ul>

<p><b>v1.51 (11 February 2005)</b></p>
<ul>
  <li> Addition of a virtual GetEventLogSourceName method which allows the name of the event log source to be customized at runtime. Thanks to                          Bara Cek for requesting this addition.</li>
  <li> Updated the copyright details in all modules.</li>
  <li> Addition of true Visual Studio .NET 2003 files for the sample service (OcsService.sln and OcsService.vcproj)</li>
</ul>

<p><b>v1.52 (26 March 2005)</b></p>
<ul>
  <li> Addition of a m_bProfileWriteFlush variable to the
    CNTService class which dictates if the registry settings should be committed immediately as                          
	opposed to relying on the lazy writer.</li>
</ul>

<p><b>v1.53 (21 April 2005)</b></p>
<ul>
  <li> CNTService::GetProfileInt and GetProfileString functions now includes an optional DWORD output parameter which when provided allows the value from
    GetLastError to be returned to client code. This allows code to distinguish between a default value which is returned because it is actually                          stored as opposed to returning a default value because some of the registry API's failed. Thanks to Tony Ronan for reporting this issue.</li>
</ul>

<p><b>v1.54 (31 July 2005)</b></p>
<ul>
  <li>Provided an overridden version of CNTEventLogSource::Report which has 3 string parameters</li>
  <li>CNTEventLogSource::GetStringArrayFromRegistry and SetStringArrayIntoRegistry methods are now public as they are helpful to have available                          externally.</li>
</ul>

<p><b>v1.55 (14 August 2005)</b></p>
<ul>
  <li> Fixed an issue where the SID and binary values was not being set correctly in the overloaded CEventLogRecord constructor which takes                          a EVENTLOGRECORD pointer. Thanks to Brian Lee for reporting this issue. Also the arrays which this information is copied into is now preallocated to                          improve performance.</li>
</ul>

<p><b>v1.56 (11 January 2006)</b></p>
<ul>
	<li>The command line options which the service uses to start with can now be 
	specified via a new /SCL command line option e.g. OcsService.exe /install &quot;/SCL:/Param1 
	/SomeOtherParam:XYZ&quot;. This additional flexibility is controlled by BOOL 
	CNTService::m_bAllowCommandLine which by default is FALSE.</li>
	<li>Updated copyright details for all modules</li>
	<li>The service display name string which the service 
	uses for installing can now be specified via a new /SDN command line option. 
	This is achieved by supporting a new command line option e.g. OcsService.exe /install &quot;/SDN:PJ's Second Test Service&quot;. This additional flexibility is controlled by BOOL 
	CNTService::m_bAllowDisplayNameChange which by default is
	FALSE. </li>
	<li>The description string which the service uses for 
	installing can now be specified via a new /SD command line option. This is 
	achieved by supporting a new command line option e.g. OcsService.exe /install 
	&quot;/SD:Some description&quot;. This additional flexibility is 
	controlled by BOOL CNTService::m_bAllowDescriptionChange which by default is 
	FALSE.</li>
	<li>The service name string which the service uses for 
	installing can now be specified via a new /SN command line option. This is 
	achieved by supporting a new command line option e.g. OcsService.exe /install 
	&quot;/SN:PJSERVICE2&quot;.</li>
	<li>Removed code which writes an event log entry when the 
	service is being uninstalling. There is not much sense in logging an entry 
	that you have uninstalled the service, when you are also uninstalling the 
	event log source.</li>
	<li>Removed the ANSI mc file. Instead now the mc file 
	included in the zip file is the Unicode mc file as provided by Brodie 
	Thiesfield (see the history list for v1.35).</li>
	<li>Updated the documentation to use the same style as 
	the web site.</li>
	<li>When registering the service, the quoting of the path name to use for 
	the service is now done in CNTService::ProcessShellCommand instead of 
	CNTScmService::Create.</li>
	<li>Optimized code in CNTServiceCommandLineInfo::CNTServiceCommandLineInfo.</li>
	<li>Removed unnecessary CNTServiceCommandLineInfo destructor.</li>
	<li>Removal of CNTService::GetEventLogSourceName method. Instead now you can 
	call m_EventLogSource.SetSourceName() to customize this value.</li>
	<li>Provision of CNTService::SetUseConsole and CNTService::GetUseConsole 
	methods.</li>
	<li>The default setting for CNTService::m_bUseConsole is now set depending 
	on whether the standard _CONSOLE preprocessor define is declared</li>
	<li>Removed the unnecessary critical section lock in the CNTService 
	constructor</li>
	<li>Provision of CNTService::SetControlsAccepted and 
	CNTService::GetControlsAccepted methods.</li>
	<li>Provision of a default CNTService constructor</li>
	<li>Addition of a default constructor for CNTEventLogSource </li>
	<li>Addition of CNTEventLogSource::SetServerName, 
	CNTEventLogSource::GetServerName, CNTEventLogSource::SetSourceName and 
	CNTEventLogSource::GetSourceName methods</li>
	<li>Provision of CNTService::SetServiceName, 
	CNTService::SetInstanceServiceName, CNTService::SetMasterServiceName, 
	CNTService::GetInstanceServiceName, CNTService::GetMasterServiceName, 
	CNTService::SetDisplayName, CNTService::SetMasterDisplayName, CNTService::SetInstanceDisplayName, 
	CNTService::GetMasterDisplayName, CNTService::GetInstanceDisplayName, 
	CNTService::SetDescription, CNTService::SetMasterDescription, 
	CNTService::SetInstanceDescription methods, CNTService::GetMasterDescription 
	and CNTService::GetInstanceDescription. Most of the work for this release of the 
	framework is to support a new concept of &quot;instances&quot; in CNTService. Prior to 
	this version of the CNTService framework, you could only ever install a 
	single copy of any one service on the one machine. Now with the introduction 
	of the /SDN, /SD and /SN command line options which are used during install 
	and uninstall you can register the service multiple times, using different 
	service names, display names and descriptions. The original values you 
	construct your CNTService instance are called the master values and are 
	unmodified during the lifetime of all instances of your services. The 
	&quot;instance&quot; values are modifiable (if you allow them to be so via 
	CNTService::m_bAllowNameChange, CNTService::m_bAllowDisplayNameChange and 
	CNTService::m_bAllowDescriptionChange) at runtime. When these values are 
	provided on the command line during registration, the command line which the 
	service is setup to use upon launch by the SCM is customized so that these 
	same command line options are passed to it. This allows the same instance 
	values to be available to the service when it is running as a service. 
	Without this neat trick, there would be no easy way for the service to 
	detect under which instance details it should run.</li>
	<li>Addition of 2 new command line options namely &quot;/App&quot; or &quot;/Application&quot;. These behave 
	the same way as the existing &quot;/Debug&quot; command line option.</li>
	<li>Addition of a DWORD* parameter to the 
	CNTEventLogSource::GetStringArrayFromRegistry and 
	CNTEventLogSource::SetStringArrayFromRegistry functions. This allow the 
	details of the last error to be returned to client code.</li>
	<li>Addition of generic versions of CNTService::WriteProfileString, 
	CNTService::WriteProfileInt, CNTService::WriteProfileStringArray, 
	CNTService::WriteProfileBinary, CNTService::GetProfileString, 
	CNTService::GetProfileInt, CNTService::GetProfileStringArray and 
	CNTService::GetProfileBinary. These implementations allow the service name 
	to be specified as well as the Flushing setting which is hidden by the other 
	implementations. The existing implementations of these functions now simply 
	call these new implementations. Providing these implementations now allows 
	client code to read and write the settings for any service (including other 
	instances of the same service) without the need to create a new CNTService 
	instance.</li>
	<li>CNTServiceControlManager::EnumServices method now uses a void* parameter 
	for its item data instead of a DWORD.</li>
	<li>Addition of a CNTService::EnumerateInstances method which allows you to 
	enumerate all the instances of a service which have been installed using the 
	new master / instance additions to the framework in this version. This could 
	prove useful where you are writing configuration type applets which 
	configure the settings for all the instances of your installed service.</li>
	<li>Addition of a new /U command line option which allows the user account 
	which the service runs under to be configured.</li>
	<li>Addition of a new /P command line option which allows the password which 
	the service is to run with to be configured.</li>
	<li>As a security precaution once the username and password strings have 
	been used for installing, they are overwritten in memory.</li>
</ul>

<p><b>v1.57 (13 January 2006)</b></p>
<ul>
	<li>Addition of a new /AUTO command line option which allows you to specify 
	that the service should be started automatically.</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>

<p>&nbsp;</p>

<h2><a name="APIReference"></a><strong>Class
Framework Reference</strong></h2>

<p>The framework consists of the following classes:</p>

<p>&nbsp;</p>

<p><b><a href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a><br>
<a href="#sumCNTEventLogSource">CNTEventLogSource</a><br>
<a href="#sumCNTService">CNTService</a><br>
<a href="#sumCNTScmService">CNTScmService</a><br>
<a href="#sumCNTServiceControlManager">CNTServiceControlManager</a><br>
<a href="#sumCEventLogRecord">CEventLogRecord</a><br>
<a href="#sumCNTEventLog">CNTEventLog</a></b></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="CNTServiceCommandLineInfo"></a><strong>CNTServiceCommandLineInfo</strong></p>

<p>The <span class="op">CNTServiceCommandLineInfo</span>
class aids in parsing the command line at application start-up. It is based almost exactly
upon the way that the&nbsp; CCommandLineInfo class in MFC works.</p>

<p>A service application will typically create a local
instance of this class in your main/wmain or InitInstance function. This object is then
passed to CNTService::ParseCommandLine, which fills the <span class="op">CNTServiceCommandLineInfo</span>
object. The <span class="op">CNTServiceCommandLineInfo</span> object is then passed to
CNTService::ProcessShellCommand to handle the command-line arguments and flags.</p>

<p>You can use this object to encapsulate the following
command-line options and parameters:</p>

<table border="0" cellPadding="7" cols="2">
<COLGROUP>
</COLGROUP>
<TBODY>
  <tr>
    <td vAlign="top"><p class="th"><b>Command-line argument</b></td>
    <td vAlign="top"><p class="th"><b>Command executed</b></td>
  </tr>
  <tr>
    <td colSpan="2" vAlign="top"></td>
  </tr>
  <tr>
    <td vAlign="top"><p class="tt"><span
    class="l">/install</span></td>
    <td vAlign="top"><p class="tt">Installs the service.</td>
  </tr>
  <tr>
    <td vAlign="top"><p class="tt"><span
    class="l">/remove | /uninstall</span></td>
    <td vAlign="top"><p class="tt">Uninstalls the service.</td>
  </tr>
  <tr>
    <td vAlign="top"><p class="tt"><span
    class="l">/help [ /?]</span></td>
    <td vAlign="top"><p class="tt">Calls the virtual CNTService::OnHelp
    function.</td>
  </tr>
  <tr>
    <td vAlign="top">/debug | /app | /Application</td>
    <td vAlign="top">Using this setting bypasses the service SCM start-up code 
	and instead runs your code as a standard application.</td>
  </tr>
  <tr>
    <td vAlign="top">/start</td>
    <td vAlign="top">Starts the service.</td>
  </tr>
  <tr>
    <td vAlign="top">/stop</td>
    <td vAlign="top">Stops the service.</td>
  </tr>
  <tr>
    <td vAlign="top">/pause</td>
    <td vAlign="top">Pauses the service.</td>
  </tr>
  <tr>
    <td vAlign="top">/continue</td>
    <td vAlign="top">Continues the service.</td>
  </tr>
  <tr>
    <td vAlign="top">/auto</td>
    <td vAlign="top">Installs the service as an automatic start-up service, as 
	opposed to a manual start-up service which is the default (should be used in 
	conjunction with the /install argument)</td>
  </tr>
  <tr>
    <td vAlign="top">/SCL:XYZ</td>
    <td vAlign="top">Provides the command line which the code should use when 
	running as a service by the SCM.</td>
  </tr>
  <tr>
    <td vAlign="top">/SD:WYZ</td>
    <td vAlign="top">Provides the service description to use.</td>
  </tr>
  <tr>
    <td vAlign="top">/SDN:PRQ</td>
    <td vAlign="top">Provides the service display name to use.</td>
  </tr>
  <tr>
    <td vAlign="top">/silent</td>
    <td vAlign="top">Use this command line in conjunction 
    with other command line arguments to support any message boxes or console 
    output which the framework generates.</td>
  </tr>
  <tr>
    <td vAlign="top">/U:ABC</td>
    <td vAlign="top">Allows you to configure the username account under which 
	the service runs.</td>
  </tr>
  <tr>
    <td vAlign="top">/P:DEF</td>
    <td vAlign="top">Allows you to configure the password for the associated 
	username account under which the service runs.</td>
  </tr>
</TBODY>
</table>

<p class="spacing">&nbsp;</p>

<p>Derive a new class from <span class="op">CCommandLineInfo</span>
to handle other flags and parameter values.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="sumCNTEventLogSource"></a><strong>CNTEventLogSource</strong></p>

<p>CNTEventLogSource provides a wrapper class for writing
events to the NT event log. You could consider this as the server side to the Event log
APIs.</p>

<p>&nbsp;</p>

<p><strong>Functions this class provides include:</strong></p>

<p><b><a href="#CNTEventLogSource">CNTEventLogSource<br>
</a><a href="#~CNTEventLogSource">~CNTEventLogSource<br>
</a><a href="#elsHandle">operator HANDLE<br>
</a><a href="#elsAttach">Attach<br>
</a><a href="#elsDetach">Detach<br>
</a><a href="#register">Register<br>
</a><a href="#Report">Report<br>
</a><a href="#Deregister">Deregister<br>
</a><a href="#elsInstall">Install<br>
</a><a href="#elsUninstall">Uninstall</a></b></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="CNTEventLogSource"></a><strong>CNTEventLogSource::CNTEventLogSource</strong></p>

<p><strong>CNTEventLogSource();</strong></p>

<p><strong>CNTEventLogSource(LPCTSTR </strong><i>lpUNCServerName</i><strong>, LPCTSTR
</strong><i> lpSourceName</i><strong>);</strong></p>

<p><strong>Remarks</strong></p>

<p>This is the constructor which just initializes
all
internal variables to a safe state.</p>

<p><strong>See Also </strong><a href="#~CNTEventLogSource">~CNTEventLogSource</a></p>

<p>&nbsp;</p>

<p><a name="~CNTEventLogSource"></a><strong>CNTEventLogSource::~CNTEventLogSource</strong></p>

<p><strong>~CNTEventLogSource();</strong></p>

<p><strong>Remarks</strong></p>

<p>This is the standard destructor for the class. Internally
it will call <a href="#register">Deregister</a> to ensure that any handle that is opened
by this instance is closed</p>

<p><strong>See Also </strong><a href="#CNTEventLogSource">CNTEventLogSource</a>
<a href="#Deregister">Deregister</a></p>

<p>&nbsp;</p>

<p><a name="elsHandle"></a><strong>CNTEventLogSource::operator
HANDLE</strong></p>

<p><strong>operator HANDLE() const;</strong></p>

<p><strong>Return Value:</strong></p>

<p>The underlying SDK handle representing this event log
source.</p>

<p><strong>Remarks</strong></p>

<p>This function exposes the underlying handle which the
CNTEventLogSource class wraps. This function is provided for integration with legacy code
which uses the handle directly</p>

<p>&nbsp;</p>

<p><a name="elsAttach"></a><strong>CNTEventLogSource::Attach</strong></p>

<p><strong>BOOL Attach(HANDLE </strong><em>hEventSource</em><strong>);</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if the function was successful, otherwise FALSE. To
get extended error information, call GetLastError </p>

<p><strong>Parameters</strong></p>

<p><em>hEventSource</em> An SDK event log source handle
returned from ::RegisterEventSource</p>

<p><strong>Remarks</strong></p>

<p>Use this member function to attach an existing SDK handle
to a CNTEventLogSource.</p>

<p><strong>See Also</strong> <a href="#elsDetach">Detach</a></p>

<p>&nbsp;</p>

<p><a name="elsDetach"></a><strong>CNTEvenLogSource::Detach</strong></p>

<p><strong>HANDLE Detach();</strong></p>

<p><strong>Return Value</strong></p>

<p>The SDK event log source handle</p>

<p><strong>Remarks</strong></p>

<p>Call this function to detach m_hEventLogSource from the
CNTEventLogSource object and&nbsp; set m_hEventLogSource to NULL.</p>

<p><strong>See Also</strong> <a href="#elsAttach">Attach</a></p>

<p>&nbsp;</p>

<p><a name="register"></a><strong>CNTEventLogSource::Register</strong></p>

<p><strong>BOOL Register(LPCTSTR </strong><em>lpUNCServerName</em><strong>,
LPCTSTR </strong><em>lpSourceName</em><strong>);</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if the function was successful, otherwise FALSE. To
get extended error information, call GetLastError </p>

<p><strong>Parameters</strong></p>

<p><i>lpUNCServerName</i> Pointer to a null-terminated string that
specifies the Universal Naming Convention (UNC) name of the server on which this operation
is to be performed. If this parameter is NULL, the operation is performed on the local
computer. </p>

<p><i>lpSourceName</i> Pointer to a null-terminated string that
specifies the name of the source referenced by the returned handle. The source name must
be a sub key of a log file entry under the <b>EventLog</b> key in the registry. For example,
WinApp is a valid source name if the registry has the following key: </p>

<p><code>HKEY_LOCAL_MACHINE <br>
&nbsp; System <br>
&nbsp;&nbsp;&nbsp; CurrentControlSet <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Services <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EventLog <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinApp <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Security <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System <br>
</code><strong>Remarks</strong></p>

<p>Use this function to register a source of logging into the
event log. Internally the CNTService class contains a member variable (m_EventLogSource)
of type CNTEventLogSource which calls this function in its construction.</p>

<p><strong>See Also</strong> <a href="#elsDetach" name="de">Deregister</a></p>

<p>&nbsp;</p>

<p><a name="Report"></a><strong>CNTEventLogSource::Report</strong></p>

<p><strong>BOOL Report(WORD </strong><em>wType</em><strong>,
WORD </strong><em>wCategory</em><strong>, DWORD </strong><em>dwEventID</em><strong>, PSID </strong><em>lpUserSid</em><strong>,
WORD </strong><em>wNumStrings</em><strong>, DWORD </strong><em>dwDataSize</em><strong>,&nbsp;LPCTSTR*
</strong><em>lpStrings</em><strong>, LPVOID </strong><em>lpRawData</em><strong>) const;</strong></p>

<p><b>  BOOL CNTEventLogSource:: Report(WORD </b><i> wType</i><b>, DWORD
</b><i> dwEventID</i><b>);</b></p>

<p><b>  BOOL CNTEventLogSource:: Report(WORD </b><i> wType</i><b>, DWORD
</b><i> dwEventID</i><b>, LPCTSTR </b><i> lpszString</i><b>);</b></p>

<p><b>  BOOL CNTEventLogSource:: Report(WORD </b><i> wType</i><b>, DWORD
</b><i> dwEventID</i><b>, LPCTSTR </b><i>lpszString1</i><b>, LPCTSTR </b><i>lpszString2</i><b>);</b></p>

<p><b>  BOOL CNTEventLogSource:: Report(WORD </b><i> wType</i><b>, DWORD
</b><i> dwEventID</i><b>, LPCTSTR </b><i>lpszString1</i><b>, LPCTSTR </b><i>lpszString2</i><b>, DWORD </b><i> dwCode,
</i><b>BOOL </b><i>bReportAsHex </i><b>= TRUE);</b></p>

<p><b>BOOL CNTEventLogSource:: Report(WORD </b><i> wType</i><b>, DWORD
</b><i> dwEventID</i><b>, LPCTSTR </b><i> lpszString</i><b>, DWORD </b><i> dwCode,
</i><b>BOOL </b><i>bReportAsHex </i><b>= TRUE);</b></p>

<p><b>BOOL CNTEventLogSource:: Report(WORD </b><i> wType</i><b>, DWORD
</b><i> dwEventID</i><b>, DWORD </b><i>dwCode, </i><b>BOOL </b><i>bReportAsHex </i><b>=
TRUE);</b></p>

<p><strong>Return Value</strong></p>

<p>TRUE if the function was successful, otherwise FALSE. To
get extended error information, call GetLastError </p>

<p><strong>Parameters</strong></p>

<p><i>wType</i> Specifies the type of event being logged. This
parameter can be one of the following values: </p>

<table cellSpacing="4" cols="2">
<TBODY>
  <tr vAlign="top">
    <th align="left" width="243">Value</th>
    <th align="left" width="222">Meaning</th>
  </tr>
  <tr vAlign="top">
    <td width="243">EVENTLOG_ERROR_TYPE</td>
    <td width="222">Error event</td>
  </tr>
  <tr vAlign="top">
    <td width="243">EVENTLOG_WARNING_TYPE</td>
    <td width="222">Warning event</td>
  </tr>
  <tr vAlign="top">
    <td width="243">EVENTLOG_INFORMATION_TYPE</td>
    <td width="222">Information event</td>
  </tr>
  <tr vAlign="top">
    <td width="243">EVENTLOG_AUDIT_SUCCESS</td>
    <td width="222">Success Audit event</td>
  </tr>
  <tr vAlign="top">
    <td width="243">EVENTLOG_AUDIT_FAILURE</td>
    <td width="222">Failure Audit event</td>
  </tr>
</TBODY>
</table>

<p><i>wCategory</i> Specifies the event category. This is
source-specific information; the category can have any value. </p>

<p><i>dwEventID</i> Specifies the event. The event identifier specifies
the message that goes with this event as an entry in the message file associated with the
event source. </p>

<p><i>lpUserSid</i> Pointer to the current user's security identifier.
This parameter can be NULL if the security identifier is not required. </p>

<p><i>wNumStrings</i> Specifies the number of strings in the array
pointed to by the <i>lpStrings</i> parameter. A value of zero indicates that no strings
are present. </p>

<p><i>dwDataSize</i> Specifies the number of bytes of event-specific
raw (binary) data to write to the log. If this parameter is zero, no event-specific data
is present. </p>

<p><i>lpStrings</i> Pointer to a buffer containing an array of
null-terminated strings that are merged into the message from the message file before
Event Viewer displays the string to the user. This parameter must be a valid pointer (or
NULL), even if <i>wNumStrings</i> is zero.</p>

<p><i>lpRawData</i> Pointer to the buffer containing the binary data.
This parameter must be a valid pointer (or NULL), even if the <i>dwDataSize</i> parameter
is zero. </p>

<p><em>lpszString</em>, <em>lpszString1</em>, <em>lpszString2</em>
Specifies a single string which will be merged into the message from the message file
before Event Viewer displays the string to the user.</p>

<p><i>dwCode</i> A DWORD value to be put into the
event log. Internally the code will convert it to an appropriate string
representation.</p>

<p><i>bReportAsHex</i> Whether or not <i>&quot;dwCode&quot;</i>
should be displayed as a hex representation or decimal.</p>

<p><strong>Remarks</strong></p>

<p>These 7 versions of Report, report a message to the event
log. The versions are provided to allow the programmer to use the one most suitable for
the particular situation at hand. </p>

<p>&nbsp;</p>

<p><a name="Deregister"></a><strong>CNTEventLogSource::Deregister</strong></p>

<p><strong>BOOL Deregister();</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if the function was successful, otherwise FALSE. To
get extended error information, call GetLastError </p>

<p><strong>Remarks</strong></p>

<p>Call this function to close the handle to the event log.
This function will be called in the destructor in case you forget to close the handle
yourself.</p>

<p><strong>See Also</strong> <a href="#register">Register</a></p>

<p>&nbsp;</p>

<p><a name="elsInstall"></a><strong>CNTEventLogSource::Install</strong></p>

<p><strong>static BOOL Install(LPCTSTR </strong><em>lpSourceName</em><strong>,
LPCTSTR </strong><em>lpEventMessageFile</em><strong>, DWORD </strong><em>dwTypesSupported</em><strong>);</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if the function was successful, otherwise FALSE. To
get extended error information, call GetLastError </p>

<p><strong>Parameters</strong></p>

<p><em>lpSourceName</em> The name of the service which you
want to install an event log source as. </p>

<p><em>lpEventMessageFile</em> The location of the binary
where the Message table resource can be located. This can be a standard exe or dll.</p>

<p><em>dwTypesSupported</em> Specifies a bitmask of supported
types. It can be one or more of the following values: </p>

<p>EVENTLOG_ERROR_TYPE<br>
EVENTLOG_WARNING_TYPE<br>
EVENTLOG_INFORMATION_TYPE<br>
EVENTLOG_AUDIT_SUCCESS<br>
EVENTLOG_AUDIT_FAILURE</p>

<p><strong>Remarks</strong></p>

<p>Call this function to setup the necessary entries in the
registry so that the Event Viewer can correctly locate the message file for messages
displayed in the event log. This function is called as part of CNTService::Install using
appropriate values.</p>

<p><strong>See Also</strong> <a href="#elsUninstall">Uninstall</a></p>

<p>&nbsp;</p>

<p><a name="elsUninstall"></a><strong>CNTEventLogSource::Uninstall</strong></p>

<p><strong>static BOOL Uninstall(LPCTSTR </strong><em>lpSourceName</em><strong>);</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if the function was successful, otherwise FALSE. To
get extended error information, call GetLastError </p>

<p><strong>Remarks</strong></p>

<p>Call this function to remove the entries from the registry
which were setup by the method Install.</p>

<p><strong>See Also</strong> <a href="#elsInstall">Install</a></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="sumCNTService"></a><strong>CNTService</strong></p>

<p>CNTService is the class which provides a C++ framework
upon which you can develop your own MFC C++ based services. The class makes heavy use of
virtual functions which your service class should override.</p>

<p>&nbsp;</p>

<p><strong>Functions this class provides include:</strong></p>

<p><b><a href="#CNTService">CNTService<br>
</a><a href="#~CNTService">~CNTService<br>
</a><a href="#WriteProfileString">WriteProfileString<br>
</a><a href="#WriteProfileInt">WriteProfileInt<br>
</a><a href="#WriteProfileBinary">WriteProfileBinary<br>
</a><a href="#WriteProfileStringArray">WriteProfileStringArray<br>
</a><a href="#GetProfileString">GetProfileString<br>
</a><a href="#GetProfileInt">GetProfileInt<br>
</a><a href="#GetProfileBinary">GetProfileBinary<br>
</a><a href="#GetProfileStringArray">GetProfileStringArray<br>
</a><a href="#ParseCommandLine">ParseCommandLine<br>
</a><a href="#ProcessShellCommand">ProcessShellCommand<br>
</a><a href="#ReportStatus">ReportStatus<br>
</a><a href="#RegisterCtrlHandler">RegisterCtrlHandler<br>
</a><a href="#ServiceCtrlHandler">ServiceCtrlHandler<br>
</a><a href="#ServiceMain">ServiceMain<br>
</a><a href="#OnStop">OnStop<br>
</a><a href="#OnPause">OnPause<br>
</a><a href="#OnContinue">OnContinue<br>
</a><a href="#OnInterrogate">OnInterrogate<br>
</a><a href="#OnShutDown">OnShutdown<br>
</a><a href="#OnUserDefinedRequest">OnUserDefinedRequest<br>
</a></b><b><a href="#OnNetBindDisable">OnParamChange</a><br>
<a href="#OnPowerEvent">OnHardwareProfileChange</a><br>
<a href="#OnPowerEvent">OnPowerEvent</a><br>
<a href="#OnNetBindAdd">OnNetBindAdd</a><br>
<a href="#OnNetBindRemove">OnNetBindRemove</a><br>
<a href="#OnNetBindEnable">OnNetBindEnable</a><br>
<a href="#OnNetBindDisable">OnNetBindDisable<br>
</a><a href="#OnDeviceEvent">OnDeviceEvent</a><br>
</b><b><a href="#Run">Run<br>
</a><a href="#Install">Install<br>
</a><a href="#Uninstall">Uninstall<br>
</a><a href="#Debug">Debug<br>
</a><a href="#ShowHelp">ShowHelp</a></b><br>
<b><a href="#EnumerateInstances">EnumerateInstances</a></b></p>

<p>&nbsp;</p>

<p>&nbsp;</p>
<p><a name="CNTService"></a><strong>CNTService::CNTService</strong></p>

<p><strong>CNTService();
</strong></p>

<p><strong>CNTService(LPCTSTR </strong><em>lpszServiceName</em><strong>,
LPCTSTR </strong><em>lpszDisplayName</em><strong>, DWORD </strong><em>dwControlsAccepted,
</em><b>LPCTSTR </b><em> lpszDescription </em><b> = NULL</b><strong>);
</strong></p>

<p><strong>Parameters</strong></p>

<p><em>lpszServiceName</em> Pointer to a null-terminated
string that is the internal name of the service. </p>

<p><em>lpszDisplayName</em> Pointer to a null-terminated
string that is to be used by user interface programs to identify this service.</p>

<p><em>dwControlsAccepted</em> Specifies the control codes
that the service will accept and process. Any of the standard NT service codes
as specified in the Platform SDK can be
specified. </p>

<p>lpszDescription The textual description of the
service. This appears in the new service's MMC snapin in Windows 2000 as the
&quot;Description&quot; column. Using this value just means that administrators
will see a comment associated with your service. The default value is NULL which
will not insert a description into the registry.</p>

<p><strong>Remarks</strong></p>

<p>This is the standard constructor which initializes
a
number of internal variables based on the parameters sent in.</p>

<p><strong>See Also </strong><a href="#~CNTService">~CNTService</a></p>

<p>&nbsp;</p>

<p><a name="~CNTService"></a><strong>CNTService::~CNTService</strong></p>

<p><strong>~CNTService();</strong></p>

<p><strong>Remarks</strong></p>

<p>Standard destructor for the class</p>

<p><strong>See Also </strong><a href="#CNTService">CNTService</a></p>

<p>&nbsp;</p>

<p><a name="WriteProfileString"></a><strong>CNTService::WriteProfileString</strong></p>

<p><strong>BOOL WriteProfileString(LPCTSTR </strong><em>lpszSection</em><strong>,
LPCTSTR </strong><em>lpszEntry</em><strong>, LPCTSTR </strong><em>lpszValue</em><strong>);</strong></p>
<p><strong>BOOL WriteProfileString(LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszService</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>
LPCTSTR </strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong>
<strong>LPCTSTR </strong><strong style="font-weight: 400"><i>lpszValue</i>,
</strong><strong>BOOL </strong><strong style="font-weight: 400"><i>bFlush</i>,
</strong><strong>DWORD* </strong><strong style="font-weight: 400"><i>pLastError</i></strong><strong>);</strong></p>
<p><strong>Return Value</strong></p>

<p>TRUE if successful; otherwise FALSE.</p>

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">lpszService</span></em>&nbsp;Points
to a null-terminated string that specifies the service containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>

<p><em><span class="p">lpszSection</span></em>&nbsp;Points
to a null-terminated string that specifies the section containing the entry. If the
section does not exist, it is created. The name of the section is case independent; the
string may be any combination of uppercase and lowercase letters.</p>

<p><em><span class="p">lpszEntry</span></em>&nbsp;Points to
a null-terminated string that contains the entry into which the value is to be written. If
the entry does not exist in the specified section, it is created.</p>

<p><em><span class="p">lpszValue</span></em> Points to the
string to be written. If this parameter is <span class="op">NULL</span>, the entry
specified by the <span class="p">lpszEntry</span> parameter is deleted. </p>

<p class="rl"><strong>Remarks</strong></p>

<p>Call this member function to write the specified string
into the registry where Services are meant to store their configuration setting i.e.
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ServiceName\Parameters.</p>

<p>&nbsp;</p>

<p><a name="WriteProfileInt"></a><strong>CNTService::WriteProfileInt</strong></p>

<p><strong>BOOL WriteProfileInt(LPCTSTR </strong><em>lpszSection</em><strong>,
LPCTSTR </strong><em>lpszEntry</em><strong>, int </strong><em>nValue</em><strong>);</strong></p>
<p><strong>BOOL WriteProfileInt(LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszService</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>
LPCTSTR </strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong>
<strong>int </strong><strong style="font-weight: 400"><i>nValue</i>, </strong>
<strong>BOOL </strong><strong style="font-weight: 400">bFlush, </strong><strong>
DWORD* </strong><strong style="font-weight: 400">pLastError</strong><strong>);</strong></p>
<p><strong>Return Value</strong></p>

<p>TRUE if successful; otherwise FALSE.</p>

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">lpszService</span></em>&nbsp;Points
to a null-terminated string that specifies the service containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>

<p><em><span class="p">lpszSection</span></em> Points to a
null-terminated string that specifies the section containing the entry. If the section
does not exist, it is created. The name of the section is case independent; the string may
be any combination of uppercase and lowercase letters.</p>

<p><em><span class="p">lpszEntry</span></em> Points to a
null-terminated string that contains the entry into which the value is to be written. If
the entry does not exist in the specified section, it is created.</p>

<p><em><span class="p">nValue</span></em> Contains the
value to be written.</p>

<p class="rl"><strong>Remarks</strong></p>

<p>Call this member function to write the specified value
into the registry where Services are meant to store their configuration setting i.e.
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ServiceName\Parameters.</p>

<p>&nbsp;</p>

<p><a name="WriteProfileBinary"></a><strong>CNTService::WriteProfileBinary</strong></p>

<p><strong>BOOL WriteProfileBinary(LPCTSTR </strong><em>lpszSection</em><strong>,
LPCTSTR </strong><em>lpszEntry</em><strong>, LPBYTE </strong><em>pData</em><strong>, UINT </strong><em>nBytes</em><strong>);</strong></p>
<p><strong>BOOL WriteProfileBinary(LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszService</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>
LPCTSTR </strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong>
<strong>LPBYTE </strong><strong style="font-weight: 400"><i>pData</i>, </strong>
<strong>UINT </strong><strong style="font-weight: 400">nBytes, </strong><strong>
BOOL </strong><strong style="font-weight: 400"><i>bFlush</i>, </strong><strong>
DWORD* </strong><strong style="font-weight: 400">pLastError</strong><strong>);</strong></p>
<p><strong>Return Value</strong></p>

<p>TRUE if successful; otherwise FALSE.</p>

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">lpszService</span></em>&nbsp;Points
to a null-terminated string that specifies the service containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>

<p><em><span class="p">lpszSection</span></em>&nbsp;Points
to a null-terminated string that specifies the section containing the entry. If the
section does not exist, it is created. The name of the section is case independent; the
string may be any combination of uppercase and lowercase letters.</p>

<p><em><span class="p">lpszEntry</span></em>&nbsp;Points to
a null-terminated string that contains the entry into which the value is to be written. If
the entry does not exist in the specified section, it is created.</p>

<p><em><span class="p">pData</span></em> Points to the
binary data to be written.</p>

<p>nBytes The size of &quot;pData&quot; in bytes.</p>

<p class="rl"><strong>Remarks</strong></p>

<p>Call this member function to write the specified binary
data into the registry where Services are meant to store their configuration setting i.e.
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ServiceName\Parameters.</p>

<p>&nbsp;</p>

<p><a name="WriteProfileStringArray"></a><strong>CNTService::WriteProfileStringArray</strong></p>

<p><strong>BOOL WriteProfileStringArray(LPCTSTR </strong><em>lpszSection</em><strong>,
LPCTSTR </strong><em>lpszEntry</em><strong>, const CStringArray&amp; </strong><em>array</em><strong>);</strong></p>
<p><b>BOOL WriteProfileStringArray(LPCTSTR </b><i>lpszService</i>, <b>LPCTSTR
</b><i>lpszSection</i>, <b>LPCTSTR </b><i>lpszEntry</i>, <b>const CStringArray&amp;
</b><i>array</i>, <b>BOOL </b><i>bFlush</i>, <b>DWORD* </b><i>pLastError</i><b>);</b></p>
<p><strong>Return Value</strong></p>

<p>TRUE if successful; otherwise FALSE.</p>

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">lpszService</span></em>&nbsp;Points
to a null-terminated string that specifies the service containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>

<p><em><span class="p">lpszSection</span></em>&nbsp;Points
to a null-terminated string that specifies the section containing the entry. If the
section does not exist, it is created. The name of the section is case independent; the
string may be any combination of uppercase and lowercase letters.</p>

<p><em><span class="p">lpszEntry</span></em>&nbsp;Points to
a null-terminated string that contains the entry into which the value is to be written. If
the entry does not exist in the specified section, it is created.</p>

<p><em><span class="p">array</span></em> The CStringArray
to be written.</p>

<p class="rl"><strong>Remarks</strong></p>

<p>Call this member function to write the specified string
array into the registry where Services are meant to store their configuration setting i.e.
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ServiceName\Parameters. The value
will be stored as a MULTI_SZ string in the registry.</p>

<p>&nbsp;</p>

<p><a name="GetProfileString"></a><strong>CNTService::GetProfileString</strong></p>

<p><strong>CString GetProfileString(LPCTSTR </strong><em>lpszSection</em><strong>,
LPCTSTR </strong><em>lpszEntry</em><strong>, LPCTSTR </strong><em>lpszDefault</em><strong>
= NULL</strong><em>, </em><b> DWORD* </b><i>pdwLastError</i><b> = NULL</b><strong>);</strong></p>
<p><strong>CString GetProfileString(LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszService</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>
LPCTSTR </strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong>
<strong>LPCTSTR </strong><i><strong style="font-weight: 400">lpszDefault</strong></i><strong> 
= NULL</strong><strong style="font-weight: 400">, </strong><strong>DWORD*
</strong><strong style="font-weight: 400"><i>pLastError</i></strong><strong> = 
NULL);</strong></p>

<p class="rl"><strong>Return Value</strong></p>

<p>The return value is the string from the registry or <span
class="p">lpszDefault</span> if the string cannot be found. The maximum string length
supported by the framework is <span class="op">_MAX_PATH</span>. If <span class="p">lpszDefault</span>
is <span class="op">NULL</span>, the return value is an empty string.</p>

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">lpszService</span></em>&nbsp;Points
to a null-terminated string that specifies the service containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>

<p><em><span class="p">lpszSection</span></em> Points to a
null-terminated string that specifies the section containing the entry.</p>

<p><em><span class="p">lpszEntry</span></em> Points to a
null-terminated string that contains the entry whose string is to be retrieved. This value
must not be <span class="op">NULL</span>.</p>

<p><em><span class="p">lpszDefault</span></em> Points to
the default string value for the given entry if the entry cannot be found in the registry.</p>

<p><i>pdwLastError</i> If this value is non-null,
then upon return it will contain the value from the function GetLastError. This allows code to distinguish between a default value which is returned because it is actually stored as&nbsp;opposed to returning a default value because some of the registry API's failed.</p>

<p class="rl"><strong>Remarks</strong></p>

<p>Call this member function to retrieve the string
associated with an entry within the specified section in the registry.</p>

<p>&nbsp;</p>

<p><a name="GetProfileInt"></a><strong>CNTService::GetProfileInt</strong></p>

<p><strong>UINT GetProfileInt(LPCTSTR </strong><em>lpszSection</em><strong>,
LPCTSTR </strong><em>lpszEntry</em><strong>, int </strong><em>nDefault, </em><b> DWORD*
</b><i>pdwLastError</i><b> = NULL</b><strong>);</strong></p>
<p><strong>UINT GetProfileInt(LPCTSTR </strong><strong style="font-weight: 400">
<i>lpszService</i>, </strong><strong>LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong><strong>int 
nDefault</strong><strong style="font-weight: 400">, </strong><strong>DWORD*
</strong><strong style="font-weight: 400"><i>pLastError</i></strong><strong> = 
NULL);</strong></p>

<p class="rl"><strong>Return Value</strong></p>

<p>The integer value of the string that follows the specified
entry if the function is successful. The return value is the value of the <span class="p">nDefault</span>
parameter if the function does not find the entry.</p>

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">lpszService</span></em>&nbsp;Points
to a null-terminated string that specifies the service containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>

<p><em><span class="p">lpszSection</span></em> Points to a
null-terminated string that specifies the section containing the entry.</p>

<p><em><span class="p">lpszEntry</span></em>&nbsp;Points to
a null-terminated string that contains the entry whose value is to be retrieved.</p>

<p><span class="p">nDefault</span> Specifies the default
value to return if the framework cannot find the entry.</p>

<p><i>pdwLastError</i> If this value is non-null,
then upon return it will contain the value from the function GetLastError. This allows code to distinguish between a default value which is returned because it is actually stored as
opposed to returning a default value because some of the registry API's failed.</p>

<p class="rl"><strong>Remarks</strong></p>

<p>Call this member function to retrieve the value of an
integer from an entry within a specified section in the registry. </p>

<p>This member function is not case sensitive, so the strings
in the <span class="p">lpszSection</span> and <span class="p">lpszEntry</span> parameters
may differ in case.</p>

<p>&nbsp;</p>

<p><a name="GetProfileBinary"></a><strong>CNTService::GetProfileBinary</strong></p>

<p><strong>BOOL GetProfileBinary(LPCTSTR </strong><em>lpszSection</em><strong>,
LPCTSTR </strong><em>lpszEntry</em><strong>, LPBYTE* </strong><em>ppData</em><strong>,
UINT* </strong><em>pBytes</em><strong>);</strong></p>
<p><strong>BOOL GetProfileBinary(LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszService</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>
LPCTSTR </strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong>
<strong>LPBYTE* <i>ppData</i></strong><strong style="font-weight: 400">,
</strong><strong>UINT* </strong><strong style="font-weight: 400"><i>pBytes</i>,
</strong><strong>DWORD* </strong><strong style="font-weight: 400"><i>pLastError</i></strong><strong> 
= NULL);</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if successful; otherwise FALSE.</p>

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">lpszService</span></em>&nbsp;Points
to a null-terminated string that specifies the service containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>

<p><em><span class="p">lpszSection</span></em> Points to a
null-terminated string that specifies the section containing the entry.</p>

<p><em><span class="p">lpszEntry</span></em> Points to a
null-terminated string that contains the entry whose binary data is to be retrieved. This
value must not be <span class="op">NULL</span>.</p>

<p><em><span class="p">ppData</span></em> Upon successful
return, this pointer will contain the binary data read from the registry.</p>

<p>nBytes Upon successful return, this pointer will contain
the size of the binary data read from the registry.</p>

<p class="rl"><strong>Remarks</strong></p>

<p>Call this member function to set a binary value associated
with an entry within the specified section in the registry. Internally the data is stored
in the registry as a REG_BINARY value. Note that the caller of the function is responsible
for freeing the memory associated with the data in &quot;ppData&quot;. This can be
achieved using: &quot;delete [] *ppData&quot;.</p>

<p>&nbsp;</p>

<p><a name="GetProfileStringArray"></a><strong>CNTService::GetProfileStringArray</strong></p>

<p><strong>BOOL GetProfileStringArray(LPCTSTR </strong><em>lpszSection</em><strong>,
LPCTSTR </strong><em>lpszEntry</em><strong>, CStringArray&amp; </strong><em>array</em><strong>);</strong></p>
<p><strong>BOOL GetProfileStringArray(LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszService</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>
LPCTSTR </strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong>
<strong>CStringArray&amp; </strong><strong style="font-weight: 400"><i>array</i>,
</strong><strong>DWORD* </strong><strong style="font-weight: 400">pLastError</strong><strong>);</strong></p>
<p><strong>Return Value</strong></p>

<p>TRUE if successful; otherwise FALSE.</p>

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">lpszService</span></em>&nbsp;Points
to a null-terminated string that specifies the service containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>

<p><em><span class="p">lpszSection</span></em> Points to a
null-terminated string that specifies the section containing the entry.</p>

<p><em><span class="p">lpszEntry</span></em> Points to a
null-terminated string that contains the entry whose string array is to be retrieved. This
value must not be <span class="op">NULL</span>.</p>

<p><em><span class="p">array </span></em>Upon successful
return this will contain the CStringArray.</p>

<p class="rl"><strong>Remarks</strong></p>

<p>Call this member function to retrieve a string array
associated with an entry within the specified section in the registry. The value is stored
as a MULTI_SZ string in the registry.</p>

<p>&nbsp;</p>

<p><a name="ParseCommandLine"></a><strong>CNTService::ParseCommandLine</strong></p>

<p><strong>void
ParseCommandLine(CNTServiceCommandLineInfo&amp; </strong><em>rCmdInfo</em><strong>);</strong></p>

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">rCmdInfo</span></em> A reference to
a <a class="normal" href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a><span
class="op"> </span>object.</p>

<p class="rl"><strong>Remarks</strong></p>

<p>Call this member function to parse the command line and
send the parameters, one at a time, to CNTServiceCommandLineInfo::ParseParam.</p>

<p>&nbsp;</p>

<p><a name="ProcessShellCommand"></a><strong>CNTService::ProcessShellCommand</strong></p>

<p><strong>DWORD</strong><strong>
ProcessShellCommand(CNTServiceCommandLineInfo&amp; </strong><em>rCmdInfo</em><strong>);</strong></p>

<p class="rl"><strong>Return Value</strong></p>

<p>The Win32 error code if the shell command fails, 
otherwise ERROR_SUCCESS (0) if successful.</p>

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">rCmdInfo</span></em>&nbsp;A
reference to a <a class="normal" href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a>
object.</p>

<p class="rl"><strong>Remarks</strong></p>

<p>This member function is called by your InitInstance, main
or wmain to accept the parameters passed from the <span class="op">CNTServiceCommandLineInfo</span>
object identified by <span class="p">rCmdInfo</span>, and perform the indicated action. </p>

<p>The &quot;m_nShellCommand&quot; data member of the <span class="op">CNTServiceCommandLineInfo</span> 
object is of the following
enumerated type, which is defined within the <span class="op">CNTServiceCommandLineInfo</span>
class.</p>

<pre>enum{
    RunAsService,
    StartTheService,
    PauseService,
    ContinueService,
    StopService,
    InstallService,
    UninstallService,
    DebugService,
    ShowServiceHelp
};</pre>

<pre>Please note that prior to v1.39, the return value from this function was a BOOL. Please ensure you review your code to make sure it correctly handles this change.</pre>

<p>&nbsp;</p>

<p><a name="ReportStatus"></a><strong>CNTService::ReportStatus</strong></p>

<p><strong>BOOL ReportStatus();</strong></p>

<p><b>	BOOL ReportStatus(DWORD </b><i>dwCurrentState</i><b>,                         DWORD
</b><i> dwCheckPoint</i><b> = STATE_NO_CHANGE, DWORD </b><i> dwWaitHint </i><b> =
STATE_NO_CHANGE, DWORD
</b><i>dwControlsAccepted</i><b> = STATE_NO_CHANGE);</b></p>

<p class="rl"><strong>Return Value</strong></p>

<p>TRUE if the SCM was notified successfully of this services
state otherwise FALSE. To get extended error information, call GetLastError </p>

<p class="rl"><strong>Parameters</strong></p>

<p><em>dwCurrentState</em> Indicates the current state of
the service. One of the following values is specified: </p>

<table cellSpacing="4" cols="2" width="794">
<TBODY>
  <tr vAlign="top">
    <th align="left" width="239">Value</th>
    <th align="left" width="535">Meaning</th>
  </tr>
  <tr vAlign="top">
    <td width="239">SERVICE_STOPPED</td>
    <td width="535">The service is not running. (Please note
      that the CNTService framework looks after calling the SCM with this value
      and client code should never use this value)</td>
  </tr>
  <tr vAlign="top">
    <td width="239">SERVICE_START_PENDING</td>
    <td width="535">The service is starting.</td>
  </tr>
  <tr vAlign="top">
    <td width="239">SERVICE_STOP_PENDING</td>
    <td width="535">The service is stopping.</td>
  </tr>
  <tr vAlign="top">
    <td width="239">SERVICE_RUNNING</td>
    <td width="535">The service is running.</td>
  </tr>
  <tr vAlign="top">
    <td width="239">SERVICE_CONTINUE_PENDING</td>
    <td width="535">The service continue is pending.</td>
  </tr>
  <tr vAlign="top">
    <td width="239">SERVICE_PAUSE_PENDING</td>
    <td width="535">The service pause is pending.</td>
  </tr>
  <tr vAlign="top">
    <td width="239">SERVICE_PAUSED</td>
    <td width="535">The service is paused.</td>
  </tr>
</TBODY>
</table>

<p><em>dwWin32ExitCode</em> Specifies an Win32 error code
that the service uses to report an error that occurs when it is starting or stopping. To
return an error code specific to the service, the service must set this value to
ERROR_SERVICE_SPECIFIC_ERROR to indicate that the <b>dwServiceSpecificExitCode</b> member
contains the error code. The service should set this value to NO_ERROR when it is running
and on normal termination. </p>

<p><em>dwServiceSpecificExitCode</em> Specifies a service
specific error code that the service returns when an error occurs while the service is
starting or stopping. This value is ignored unless the <b>dwWin32ExitCode</b> member is
set to ERROR_SERVICE_SPECIFIC_ERROR.</p>

<p><em>dwCheckPoint</em> Specifies a value that the service
increments periodically to report its progress during a lengthy start, stop, pause, or
continue operation. For example, the service should increment this value as it completes
each step of its initialization when it is starting up. The user interface program that
invoked the operation on the service uses this value to track the progress of the service
during a lengthy operation. This value is not valid and should be zero when the service
does not have a start, stop, pause, or continue operation pending. </p>

<p><em>dwWaitHint</em> Specifies an estimate of the amount
of time, in milliseconds, that the service expects a pending start, stop, pause, or
continue operation to take before the service makes its next call to the <b>SetServiceStatus</b>
function with either an incremented <b>dwCheckPoint</b> value or a change in <b>dwCurrentState</b>.
If the amount of time specified by <b>dwWaitHint</b> passes, and <b>dwCheckPoint</b> has
not been incremented, or <b>dwCurrentState</b> has not changed, the service control
manager or service control program can assume that an error has occurred. </p>

<p><em>dwControlsAccepted</em> Specifies the control codes
that the service will accept and process. Any of the standard NT service codes
as specified in the Platform SDK can be
specified. These are the same codes as specified in the CNTService constructor. </p>

<p class="rl"><strong>Remarks</strong></p>

<p>These two functions report the current state of the
service back to the service control manager. The first versions uses the parameters
specified and as well as updated the services own internal state will report it to the
SCM. The second version uses the existing state of the service when reporting to the SCM.</p>

<p>&nbsp;</p>

<p><a name="RegisterCtrlHandler"></a><strong>CNTService::RegisterCtrlHandler</strong></p>

<p><strong>BOOL RegisterCtrlHandler();</strong></p>

<p class="rl"><strong>Return Value</strong></p>

<p>TRUE if the Control handler for this service was
successfully registered otherwise FALSE. To get extended error information, call
GetLastErrorr</p>

<p class="rl"><strong>Remarks</strong></p>

<p>This function is called automatically for you
prior to the framework calling your ServiceMain code, so there is normally no
need to call this function yourself. This function setups up the function on
which the SCM will callback on when making
requests to the service. Internally when a request is made it will be routed to the
appropriate virtual function.</p>

<p><strong>See Also </strong><a href="#ServiceCtrlHandler">ServiceCtrlHandler</a></p>

<p>&nbsp;</p>

<p><a name="ServiceCtrlHandler"></a><strong>CNTService::ServiceCtrlHandler</strong></p>

<p><b>DWORD ServiceCtrlHandler(DWORD </b><i>dwControl</i><b>, DWORD
</b><i>dwEventType</i><b>, LPVOID </b><i>lpEventData</i><b>)</b></p>

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">dwControl</span></em>&nbsp;Specifies
the requested control code. This value can be one of the standard control codes in the
following table: </p>

<table cellSpacing="4" cols="2" width="719">
<TBODY>
  <tr vAlign="top">
    <th align="left" width="301">Value</th>
    <th align="left" width="398">Meaning</th>
  </tr>
  <tr vAlign="top">
    <td colSpan="2" width="707"></td>
  </tr>
  <tr vAlign="top">
    <td width="301">SERVICE_CONTROL_STOP</td>
    <td width="398">Requests the service to stop. </td>
  </tr>
  <tr vAlign="top">
    <td width="301">SERVICE_CONTROL_PAUSE</td>
    <td width="398">Requests the service to pause. </td>
  </tr>
  <tr vAlign="top">
    <td width="301">SERVICE_CONTROL_CONTINUE</td>
    <td width="398">Requests the paused service to resume. </td>
  </tr>
  <tr vAlign="top">
    <td width="301">SERVICE_CONTROL_INTERROGATE</td>
    <td width="398">Requests the service to update immediately its current
    status information to the service control manager. </td>
  </tr>
  <tr>
    <td width="301">SERVICE_CONTROL_SHUTDOWN</td>
    <td width="398">Requests the service to perform cleanup tasks, because
    the system is shutting down.</td>
  </tr>
  <tr vAlign="top">
    <td width="301">SERVICE_CONTROL_PARAMCHANGE</td>
    <td width="398"><b>Windows 2000:</b> Notifies the service
      that service-specific startup parameters have changed. The service should
      reread its startup parameters.</td>
  </tr>
  <tr vAlign="top">
    <td width="301">SERVICE_CONTROL_NETBINDADD</td>
    <td width="398"><b>Windows 2000:</b> Notifies a network
      service that there is a new component for binding. The service should bind
      to the new component.</td>
  </tr>
  <tr vAlign="top">
    <td width="301">SERVICE_CONTROL_NETBINDREMOVE</td>
    <td width="398"><b>Windows 2000:</b> Notifies a network
      service that a component for binding has been removed. The service should
      reread its binding information and unbind from the removed component.</td>
  </tr>
  <tr vAlign="top">
    <td width="301">SERVICE_CONTROL_NETBINDENABLE</td>
    <td width="398"><b>Windows 2000:</b> Notifies a network
      service that a disabled binding has been enabled. The service should
      reread its binding information and add the new binding.</td>
  </tr>
  <tr>
    <td width="301">SERVICE_CONTROL_NETBINDDISABLE</td>
    <td width="398"><b>Windows 2000:</b> Notifies a network
      service that one of its bindings has been disabled. The service should
      reread its binding information and remove the binding.</td>
  </tr>
  <tr vAlign="top">
    <td width="301">SERVICE_CONTROL_DEVICEEVENT</td>
    <td width="398"><b>Windows 2000:</b> Notifies the service
      of device events. The service must register to receive these notifications
      by using the <b>RegisterDeviceNotification</b> function.</td>
  </tr>
  <tr vAlign="top">
    <td width="301">SERVICE_CONTROL_HARDWAREPROFILECHANGE</td>
    <td width="398"><b>Windows 2000:</b> Notifies the service
      that the computer's hardware profile has changed</td>
  </tr>
  <tr vAlign="top">
    <td width="301">SERVICE_CONTROL_POWEREVENT</td>
    <td width="398"><b>Windows 2000:</b> Notifies the service
      of system power events</td>
  </tr>
</TBODY>
</table>

<p>&nbsp;</p>

<p>This value can also be a user-defined control code, as described in
the following table: </p>

<table cellSpacing="4" cols="2">
<TBODY>
  <tr vAlign="top">
    <th align="left" width="165">Value</th>
    <th align="left" width="281">Meaning </th>
  </tr>
  <tr vAlign="top">
    <td width="165">Range 128 to 255.</td>
    <td width="281">The service defines the action associated with the
    control code. The <i>hService</i> handle must have SERVICE_USER_DEFINED_CONTROL access. </td>
  </tr>
</TBODY>
</table>

<p>&nbsp;</p>

<dl>
  <dt><i>dwEventType</i>
  <dd>The type of event that has occurred. If <i>dwControl</i>
    is SERVICE_CONTROL_POWEREVENT, this parameter can be one of the values
    specified in the <i>wParam</i> value of the <b>WM_POWERBROADCAST</b>
    message.
    <p>If <i>dwControl</i> is SERVICE_CONTROL_DEVICEEVENT,
    this parameter can be one of the following values: <b>DBT</b>_<b>DEVICEARRIVAL</b>,
    <b>DBT</b>_<b>DEVICEREMOVECOMPLETE</b>, <b>DBT</b>_<b>DEVICEQUERYREMOVE</b>,
    <b>DBT</b>_<b>DEVICEQUERYREMOVEFAILED</b>, <b>DBT</b>_<b>DEVICEREMOVEPENDING</b>,
    or <b>DBT</b>_<b>CUSTOMEVENT</b>.
    <p>If <i>dwControl</i> is
    SERVICE_CONTROL_HARDWAREPROFILECHANGE, this parameter can be one of the
    following values: <b>DBT</b>_<b>CONFIGCHANGED</b>, <b>DBT</b>_<b>QUERYCHANGECONFIG</b>,
    or <b>DBT</b>_<b>CONFIGCHANGECANCELED</b>.
    <p>Otherwise, this parameter is zero.</p>
  </dd>
  <dt><i>lpEventData</i>
  <dd>Additional device information, if required. The format
    of this data depends on the value of the <i>dwControl</i> and <i>dwEventType</i>
    parameters. This data corresponds to the <i>lParam</i> value that
    applications receive as part of a <b>WM_DEVICECHANGE</b> or <b>WM_POWERBROADCAST</b>
    message.</dd>
</dl>

<p>&nbsp;</p>

<p><strong>Remarks</strong></p>

<p>This function is called into by the SCM and internally it
delegates to the appropriate virtual function. For example if a&nbsp; SERVICE_CONTROL_STOP
request arrives then this function will call the virtual OnStop function. This function
will not normally have to be overridden in your derived class. Please bear in mind that
this function will be called in the context on the main thread on your service and not the
thread in which your service does it main work (its ServiceMain handler).</p>

<p>&nbsp;</p>

<p><a name="ServiceMain"></a><strong>CNTService::ServiceMain</strong></p>

<p><strong>virtual void WINAPI ServiceMain(DWORD </strong><em>dwArgc</em><strong>,
LPTSTR* </strong><em>lpszArgv</em><strong>);</strong> 

<dl>
  <p><strong>Parameters</strong></p>
</dl>

<p><i>dwArgc</i> Specifies the number of arguments in the <i>lpszArgv</i>
array.</p>

<p><i>lpszArgv</i> Pointer to an array of pointers that point to
null-terminated argument strings. The first argument in the array is the name of the
service, and subsequent arguments are any strings passed to the service by the process
that called the <a href="#scmsStart">CScmService::Start</a> function to start the service.
</p>

<p><strong>Remarks</strong></p>

<p>In your derived class you are responsible for writing your own <b>ServiceMain</b>
function for your service</p>

<p>When a service control program requests that a new service run, the
SCM starts the service and sends a start request to the control dispatcher. The control
dispatcher creates a new thread to execute the <b>ServiceMain</b> function for the
service.</p>

<p>The <b>ServiceMain</b> function should perform the following tasks: 

<ol>
  <li>Perform initialisation. If the execution time of the initialisation
    code is expected to be very short (less than one second), initialisation can be performed
    directly in <b>ServiceMain</b>, if not you should report back to the SCM
    using the state START_PENDING. Check the sample service for the details on
    how this is done.</li>
  <li>When initialisation is complete, call <b>SetServiceStatus</b>,
    specifying the SERVICE_RUNNING state in the <b>SERVICE_STATUS</b> structure. </li>
  <li>Perform the service tasks, or, if there are no pending tasks, return.
    Any change in the state of the service warrants a call to <a href="#ReportStatusToSCM">ReportStatusToSCM</a>
    to report new status information. </li>
  <li>If an error occurs while the service is initializing or running, the
    service should call , specifying the SERVICE_STOP_PENDING state, if cleanup will be
    lengthy. Once cleanup is complete, call <a href="#ReportStatusToSCM">ReportStatusToSCM</a>
    from the last thread to terminate, specifying SERVICE_STOPPED in the <b>SERVICE_STATUS</b>
    structure. Be sure to set the <b>dwServiceSpecificExitCode</b> and <b>dwWin32ExitCode</b>
    members of the <b>SERVICE_STATUS</b> structure to identify the error. </li>
</ol>

<p>&nbsp;</p>

<p><a name="OnStop"></a><strong>CNTService::OnStop</strong></p>

<p><strong>virtual void OnStop();</strong></p>

<p><strong>Remarks</strong></p>

<p>This function will be called whenever a
SERVICE_CONTROL_STOP request comes in from the SCM. Your derived class should do whatever
is necessary to cause your service to stop.</p>

<p>&nbsp;</p>

<p><a name="OnPause"></a><strong>CNTService::OnPause</strong></p>

<p><strong>virtual void OnPause();</strong></p>

<p><strong>Remarks</strong></p>

<p>This function will be called whenever a
SERVICE_CONTROL_PAUSE request comes in from the SCM. Your derived class should do whatever
is necessary to cause your service to pause.</p>

<p>&nbsp;</p>

<p><a name="OnContinue"></a><strong>CNTService::OnContinue</strong></p>

<p><strong>virtual void OnContinue();</strong></p>

<p><strong>Remarks</strong></p>

<p>This function will be called whenever a
SERVICE_CONTROL_CONTINUE request comes in from the SCM. Your derived class should do
whatever is necessary to cause your service to continue.</p>

<p>&nbsp;</p>

<p><a name="OnInterrogate"></a><strong>CNTService::OnInterrogate</strong></p>

<p><strong>virtual void OnInterrogate();</strong></p>

<p><strong>Remarks</strong></p>

<p>This function will be called whenever a
SERVICE_CONTROL_INTERROGATE request comes in from the SCM. The default implementation just
calls <a href="#ReportStatusToSCM">ReportStatusToSCM</a> to inform the SCM.</p>

<p>&nbsp;</p>

<p><a name="OnShutDown"></a><strong>CNTService::OnShutdown</strong></p>

<p><strong>virtual void OnShutdown();</strong></p>

<p><strong>Remarks</strong></p>

<p>This function will be called whenever a
SERVICE_CONTROL_SHUTDOWN comes in from the SCM.&nbsp; Your derived class should do
whatever is necessary to cause your service to shutdown.</p>

<p>&nbsp;</p>

<p><a name="OnUserDefinedRequest"></a><strong>CNTService::OnUserDefinedRequest</strong></p>

<p><strong>virtual void OnUserDefinedRequest(DWORD </strong><em>dwControl</em><strong>);</strong></p>

<p><strong>Remarks</strong></p>

<p>This function will be called whenever a user defined
request comes in from the SCM.&nbsp; Your derived class should do whatever is appropriate
for its service. In the example service provided, it simply changes the frequency of beeps
emitted by the service.</p>

<p>&nbsp;</p>

<p><a name="OnParamChange"></a><strong>CNTService::OnParamChange</strong></p>

<p><strong>virtual void OnParamChange();</strong></p>

<p><strong>Remarks</strong></p>

<p>Notifies the service that service-specific
startup parameters have changed. The service should reread its startup
parameters. This is only called when the service is running on Windows 2000 or
later.</p>

<p>&nbsp;</p>

<p><a name="OnHardwareProfileChange"></a><strong>CNTService::OnHardwareProfileChange</strong></p>

<p><strong>virtual DWORD OnHardwareProfileChange</strong><b>(DWORD
</b><i> dwEventType</i><b>, LPVOID </b><i>lpEventData</i><b>);</b></p>

<p class="rl"><strong>Return Value</strong></p>

return NO_ERROR to grant the request and an error code to
deny the request.

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">dwEventType</span></em>&nbsp;this
parameter can be one of the following values: <b>DBT</b>_<b>CONFIGCHANGED</b>, <b>DBT</b>_<b>QUERYCHANGECONFIG</b>,
or <b>DBT</b>_<b>CONFIGCHANGECANCELED</b>.</p>

<p><i>lpEventData</i> Additional device
information, if required. The format of this data depends on the value of <i>dwEventType</i>
parameter.</p>

<p><strong>Remarks</strong></p>

<p>Notifies the service that the computer's
hardware profile has changed. This is only called when the service is running on
Windows 2000 or later.</p>

<p>&nbsp;</p>

<p><a name="OnPowerEvent"></a><strong>CNTService::OnPowerEvent</strong></p>

<p><strong>virtual DWORD OnPowerEvent</strong><b>(DWORD
</b><i> dwEventType</i><b>, LPVOID </b><i>lpEventData</i><b>);</b></p>

<p class="rl"><strong>Return Value</strong></p>

return NO_ERROR to grant the request and an error code to
deny the request.

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">dwEventType</span></em>&nbsp;this
parameter can be one of the values specified in the <i>wParam</i> value of the <b>WM_POWERBROADCAST</b>
message.</p>

<p><i>lpEventData</i> This data corresponds to the <i>lParam</i>
value that applications receive as part of a <b>WM_POWERBROADCAST</b> message.</p>

<p><strong>Remarks</strong></p>

<p>Notifies the service of system power events.
This is only called when the service is running on Windows 2000 or later.</p>

<p>&nbsp;</p>

<p><a name="OnNetBindAdd"></a><strong>CNTService::OnNetBindAdd</strong></p>

<p><b>  virtual void OnNetBindAdd();</b></p>

<p><strong>Remarks</strong></p>

<p>Notifies a network service that there is a new
component for binding. The service should bind to the new component. This is
only called when the service is running on Windows 2000 or later.</p>

<p>&nbsp;</p>

<p><a name="OnNetBindRemove"></a><strong>CNTService::OnNetBindRemove</strong></p>

<p><b>  virtual void OnNetBindRemove();</b></p>

<p><strong>Remarks</strong></p>

<p>Notifies a network service that a component for
binding has been removed. The service should reread its binding information and
unbind from the removed component. This is only called when the service is
running on Windows 2000 or later.</p>

<p>&nbsp;</p>

<p><a name="OnNetBindEnable"></a><strong>CNTService::OnNetBindEnable</strong></p>

<p><b>  virtual void OnNetBindEnable();</b></p>

<p><strong>Remarks</strong></p>

<p>Notifies a network service that a disabled
binding has been enabled. The service should reread its binding information and
add the new binding. This is only called when the service is running on Windows
2000 or later.</p>

<p>&nbsp;</p>

<p><a name="OnNetBindDisable"></a><strong>CNTService::OnNetBindDisable</strong></p>

<p><b>  virtual void OnNetBindDisable();</b></p>

<p><strong>Remarks</strong></p>

<p>Notifies a network service that one of its
bindings has been disabled. The service should reread its binding information
and remove the binding. This is only called when the service is running on
Windows 2000 or later.</p>

<p>&nbsp;</p>

<p><a name="OnDeviceEvent"></a><strong>CNTService::OnDeviceEvent</strong></p>

<p><strong>virtual DWORD OnDeviceEvent</strong><b>(DWORD
</b><i> dwEventType</i><b>, LPVOID </b><i>lpEventData</i><b>);</b></p>

<p class="rl"><strong>Return Value</strong></p>

return NO_ERROR to grant the request and an error code to
deny the request.

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">dwEventType</span></em>&nbsp;this
parameter can be one of the following values: <b>DBT</b>_<b>DEVICEARRIVAL</b>, <b>DBT</b>_<b>DEVICEREMOVECOMPLETE</b>,
<b>DBT</b>_<b>DEVICEQUERYREMOVE</b>, <b>DBT</b>_<b>DEVICEQUERYREMOVEFAILED</b>, <b>DBT</b>_<b>DEVICEREMOVEPENDING</b>,
or <b>DBT</b>_<b>CUSTOMEVENT</b></p>

<p><i>lpEventData</i>  This data corresponds to the
<i>lParam</i> value that applications receive as part of a <b>WM_DEVICECHANGE</b>
message.</p>

<p><strong>Remarks</strong></p>

<p>Notifies the service of device events. The
service must register to receive these notifications by using the <b>RegisterDeviceNotification</b>
function.
This is only called when the service is running on Windows 2000 or later.</p>

<p>&nbsp;</p>

<p><a name="Run"></a><strong>CNTService::Run</strong></p>

<p><strong>virtual BOOL Run();</strong></p>

<p><strong>Remarks</strong></p>

<p>Calling this function will cause a service to start
running. Internally it will set up an appropriate SERVICE_TABLE_ENTRY array and call
StartServiceCtrlDispatcher to kick of the service. You would normally call this in your
main, wmain or InitInstance. If you are using the <a href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a>
class and <a href="#ParseCommandLine">ParseCommandLine</a> and <a
href="#ProcessShellCommand">ProcessShellCommand</a> member functions of CNTService then
there is no need to call this function.</p>

<p>&nbsp;</p>

<p><a name="Install"></a><strong>CNTService::Install</strong></p>

<p><strong>virtual BOOL Install(CString&amp; </strong>
<strong style="font-weight: 400"><i>sErrorMsg</i>, </strong><strong>DWORD&amp; </strong>
<strong style="font-weight: 400"><i>dwError</i>);</strong></p>

<p><strong>Remarks</strong></p>

<p>This will install a service. Internally it will call into
the SCM API to set this service up as an On demand service with no dependencies. It will also install the service so that it can report events to the event log
as well as letting Event Viewer filter using the friendly name of the service. This
function will be called internally by the <a href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a>
if &quot;/install&quot; is specified on the command line.</p>

<p>&nbsp;</p>

<p><a name="Uninstall"></a><strong>CNTService::Uninstall</strong></p>

<p><strong>virtual BOOL Uninstall(CString&amp; </strong><strong style="font-weight: 400"><i>sErrorMsg</i>, </strong><strong>
DWORD&amp; </strong><strong style="font-weight: 400"><i>dwError</i>, </strong><strong>
DWORD </strong><strong style="font-weight: 400"><i>dwTimeToWaitForStop</i>);</strong></p>

<p><strong>Remarks</strong></p>

<p>The is the corollary function of Install and will remove
the service from the SCM database and unregister its' event log registry entries. Please bear in
mind that once this is done, event viewer will no longer be able to correctly display any
messages the service generated while it was installed. the <a
href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a> if &quot;-uninstall&quot;
or &quot;-remove&quot; is specified on the command line.</p>

<p>&nbsp;</p>

<p><a name="Debug"></a><strong>CNTService::Debug</strong></p>

<p><strong>virtual void Debug();</strong></p>

<p><strong>Remarks</strong></p>

<p>This will run a service without interacting with the SCM,
in effect a &quot;debug&quot; or &quot;Application&quot; mode. This helps when testing your application as it will
stop the SCM from timing out your service as it is being debugged. Internally this
function will just call the ServiceMain function of your class. Remember that in this case
your service code will be running in the same thread as the main thread so it may mask
problems which only arise when the code is executed as a real service. This function will
be called internally by <a href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a>
if &quot;/debug&quot;, /Application or /App is specified on the command line.</p>

<p>&nbsp;</p>

<p><a name="ShowHelp"></a><strong>CNTService::ShowHelp</strong></p>

<p><strong>virtual void ShowHelp();</strong></p>

<p><strong>Remarks</strong></p>

<p>This function will be called internally by <a
href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a> if &quot;-help&quot; or
&quot;-?&quot; is specified on the command line. It is up to you to either print some
message to the console if you are developing a console mode service or display some
helpful window if its a GUI app. The sample service simply displays a message using
AfxMessageBox as it was developed using the GUI subsystem.</p>

<p>&nbsp;</p>

<p><strong><a name="EnumerateInstances"></a>CNTService::EnumerateInstances</strong></p>

<p><strong>virtual BOOL EnumerateInstances(CStringArray&amp; </strong>
<strong style="font-weight: 400"><i>ServiceNames, </i></strong><strong>DWORD&amp; </strong>
<i><strong style="font-weight: 400">dwError</strong></i><strong>);</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if successful; otherwise FALSE.</p>

<p class="rl"><strong>Parameters</strong></p>

<p><em><span class="p">ServiceNames</span></em>&nbsp;Upon return will contain 
all the service name instances for this service.</p>
<p><em><span class="p">dwError </span></em>Will contain the last error code upon 
return.</p>

<p class="rl"><strong>Remarks</strong></p>

<p>Call this member function to enumerate all instances of the service. This 
could prove useful where you are writing configuration type applets which 
configure the settings for all the instances of your installed service.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="sumCNTScmService"></a><strong>CNTScmService</strong></p>

<p>CNTScmService is a class which encapsulates a service as
returned from the Service Control Manager, in effect a SC_HANDLE. An instance of a
CNTScmService is usually acquired by a call to CNTServiceControlManager::Open. Once
retrieved the class allows you to control the service, change its configuration and query
a service's state.</p>

<p>&nbsp;</p>

<p><strong>Functions this class provides include:</strong></p>

<p><b><a href="#CNTScmSevice">CNTScmService<br>
</a><a href="#~CNTScmSevice">~CNTScmService<br>
</a><a href="#scmsClose">Close<br>
</a><a href="#scmsHandle">operator SC_HANDLE<br>
</a><a href="#scmsAttach">Attach<br>
</a><a href="#scmsDetach">Detach<br>
</a><a href="#scmsChangeConfig">ChangeConfig<br>
</a><a href="#scmsControl">Control<br>
</a><a href="#scmsStop">Stop<br>
</a><a href="#scmsPause">Pause<br>
</a><a href="#scmsContinue">Continue<br>
</a><a href="#scmsInterrogate">Interrogate<br>
</a><a href="#scmsStart">Start<br>
</a><a href="#scmsStop">AcceptStop<br>
</a><a href="#scmsAcceptPauseContinue">AcceptPauseContinue<br>
</a><a href="#scmsAcceptShutdown">AcceptShutdown<br>
</a><a href="#scmsQueryStatus">QueryStatus<br>
</a><a href="#scmsQueryConfig">QueryConfig<br>
</a><a href="#scmsCreate">Create<br>
</a><a href="#scmsDelete">Delete<br>
</a><a href="#scmsEnumDependents">EnumDependents<br>
</a><a href="#scmsQueryObjectSecurity">QueryObjectSecurity<br>
</a><a href="#scmsSetObjectSecurity">SetObjectSecurity<br>
</a></b><b><a href="#ChangeFailureActions">QueryDescription</a><br>
<a href="#QueryFailureActions">
QueryFailureActions</a><br>
<a href="#ChangeFailureActions">
ChangeDescription</a><br>
<a href="#ChangeFailureActions">
ChangeFailureActions</a></b></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="CNTScmSevice"></a><strong>CNTScmService::CNTScmService</strong></p>

<p><strong>CNTScmService();</strong></p>

<p><strong>Remarks</strong></p>

<p>This is the default constructor which just initializes
all
internal variables to a safe state.</p>

<p><strong>See Also </strong><a href="#~CNTScmSevice">~CNTScmService</a></p>

<p>&nbsp;</p>

<p><a name="~CNTScmSevice"></a><strong>CNTScmService::~CNTScmService</strong></p>

<p><strong>~CNTScmService();</strong></p>

<p><strong>Remarks</strong></p>

<p>This is the standard destructor for the class. Internally
it will call <a href="#scmsClose">Close</a> to ensure that any handle that is opened by
this instance is closed</p>

<p><strong>See Also </strong><a href="#CNTScmSevice">CNTScmService</a> <a
href="#scmsClose">Close</a></p>

<p>&nbsp;</p>

<p><a name="scmsClose"></a><strong>CNTScmService::Close</strong></p>

<p><strong>void Close();</strong></p>

<p><strong>Remarks</strong></p>

<p>This frees the SC_HANDLE by internally calling
CloseServiceHandle which this class encapsulates.</p>

<p>&nbsp;</p>

<p><a name="scmsHandle"></a><strong>CNTScmService::operator
SC_HANDLE</strong></p>

<p><strong>operator SC_HANDLE() const;</strong></p>

<p><strong>Return Value:</strong></p>

<p>The underlying SDK service handle representing this class.</p>

<p><strong>Remarks</strong></p>

<p>This function exposes the underlying handle which the
CNTScmService class wraps. This function is provided for integration with legacy code
which uses the handle directly.</p>

<p>&nbsp;</p>

<p><a name="scmsAttach"></a><strong>CNTScmService::Attach</strong></p>

<p><strong>BOOL Attach(SC_HANDLE </strong><em>hService</em><strong>);</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if the function was successful, otherwise FALSE. To
get extended error information, call GetLastError </p>

<p><strong>Parameters</strong></p>

<p><em>hService</em> An SDK service handle returned from SDK
calls to the SCM APIs</p>

<p><strong>Remarks</strong></p>

<p>Use this member function to attach an existing SDK handle
to a CNTScmService.</p>

<p><strong>See Also</strong> <a href="#scmsDetach">Detach</a></p>

<p>&nbsp;</p>

<p><a name="scmsDetach"></a><strong>CNTScmService::Detach</strong></p>

<p><strong>SC_HANDLE Detach();</strong></p>

<p><strong>Return Value</strong></p>

<p>The SDK service handle</p>

<p><strong>Remarks</strong></p>

<p>Call this function to detach m_hService from the
CNTScmService object and&nbsp; set m_hService to NULL.</p>

<p><strong>See Also</strong> <a href="#scmsAttach">Attach</a></p>

<p>&nbsp;</p>

<p><a name="scmsChangeConfig"></a><strong>CNTScmService::ChangeConfig</strong></p>

<p><strong>BOOL ChangeConfig(DWORD </strong><em>dwServiceType</em><strong>,
DWORD </strong><em>dwStartType</em><strong>, DWORD </strong><em>dwErrorControl</em><strong>,
LPCTSTR </strong><em>lpBinaryPathName</em><strong>, LPCTSTR </strong><em>lpLoadOrderGroup</em><strong>,
LPDWORD </strong><em>lpdwTagId</em><strong>, LPCTSTR </strong><em>lpDependencies</em><strong>,
LPCTSTR </strong><em>lpServiceStartName</em><strong>, LPCTSTR </strong><em>lpPassword</em><strong>,
LPCTSTR </strong><em>lpDisplayName</em><strong>) const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call
ChangeServiceConfig. See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="scmsControl"></a><strong>CNTScmService::Control</strong></p>

<p><strong>BOOL Control(DWORD </strong><em>dwControl</em><strong>);</strong></p>

<p class="rl"><strong>Parameters</strong></p>

<p><em>dwControl</em> Specifies the control code to send to
this service. This value can be one of the standard control codes in the following table: </p>

<table cellSpacing="4" cols="2">
<TBODY>
  <tr vAlign="top">
    <th align="left" width="214">Value</th>
    <th align="left" width="232">Meaning</th>
  </tr>
  <tr vAlign="top">
    <td colSpan="2" width="446"></td>
  </tr>
  <tr vAlign="top">
    <td width="214">SERVICE_CONTROL_STOP</td>
    <td width="232">Requests the service to stop. </td>
  </tr>
  <tr vAlign="top">
    <td width="214">SERVICE_CONTROL_PAUSE</td>
    <td width="232">Requests the service to pause. </td>
  </tr>
  <tr vAlign="top">
    <td width="214">SERVICE_CONTROL_<br>
    CONTINUE</td>
    <td width="232">Requests the paused service to resume. </td>
  </tr>
  <tr vAlign="top">
    <td width="214">SERVICE_CONTROL_<br>
    INTERROGATE</td>
    <td width="232">Requests the service to update immediately its current
    status information to the service control manager. </td>
  </tr>
  <tr vAlign="top">
    <td width="214">SERVICE_CONTROL_<br>
    SHUTDOWN</td>
    <td width="232">Requests the service to perform cleanup tasks, because
    the system is shutting down.</td>
  </tr>
</TBODY>
</table>

<p>&nbsp;</p>

<p>This value can also be a user-defined control code, as described in
the following table: </p>

<table cellSpacing="4" cols="2">
<TBODY>
  <tr vAlign="top">
    <th align="left" width="165">Value</th>
    <th align="left" width="281">Meaning </th>
  </tr>
  <tr vAlign="top">
    <td width="165">Range 128 to 255.</td>
    <td width="281">The service defines the action associated with the
    control code. The <i>hService</i> handle must have SERVICE_USER_DEFINED_CONTROL access. </td>
  </tr>
</table>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call ControlService
SDK Call.</p>

<p>&nbsp;</p>

<p><a name="scmsStop"></a><strong>CNTScmService::Stop</strong></p>

<p><strong>BOOL Stop() const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for calling <a
href="#scmsControl">Control</a> with the parameter SERVICE_CONTROL_STOP</p>

<p>&nbsp;</p>

<p><a name="scmsPause"></a><strong>CNTScmService::Pause</strong></p>

<p><strong>BOOL Pause() const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for calling <a
href="#scmsControl">Control</a> with the parameter SERVICE_CONTROL_PAUSE</p>

<p>&nbsp;</p>

<p><a name="scmsContinue"></a><strong>CNTScmService::Continue</strong></p>

<p><strong>BOOL Continue() const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for calling <a
href="#scmsControl">Control</a> with the parameter SERVICE_CONTROL_CONTINUE</p>

<p>&nbsp;</p>

<p><a name="scmsInterrogate"></a><strong>CNTScmService::Interrogate</strong></p>

<p><strong>BOOL Interrogate() const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for calling <a
href="#scmsControl">Control</a> with the parameter SERVICE_CONTROL_INTERROGATE</p>

<p>&nbsp;</p>

<p><a name="scmsStart"></a><strong>CNTScmService::Start</strong></p>

<p><strong>BOOL Start(DWORD </strong><em>dwNumServiceArgs</em><strong>,
LPCTSTR* </strong><em>lpServiceArgVectors</em><strong>) const;</strong></p>

<p><strong>Parameters</strong></p>

<p><i>dwNumServiceArgs</i> Specifies the number of argument strings in
the <i>lpServiceArgVectors</i> array. If <i>lpServiceArgVectors</i> is NULL, this
parameter can be zero. </p>

<p><i>lpServiceArgVectors</i> Pointer to an array of pointers that
point to null-terminated argument strings passed to a service. Driver services do not
receive these arguments. If no arguments are passed to the service being started, this
parameter can be NULL. </p>

<p><strong>Return Values</strong></p>

<p>TRUE If the function succeeds otherwise FALSE. To get extended error
information, call <b>GetLastError</b>. </p>

<p><strong>Remarks</strong></p>

<p>Starts this service with the specified parameters.</p>

<p>&nbsp;</p>

<p><a name="scmsAcceptStop"></a><strong>CNTScmService::AcceptStop</strong></p>

<p><strong>BOOL AcceptStop(BOOL&amp; </strong><em>bStop</em><strong>);</strong></p>

<p><strong>Parameters</strong></p>

<p><i>bStop</i> Upon a successful return from this function, bStop will
indicate whether this service can be stopped. </p>

<p><strong>Return Values</strong></p>

<p>TRUE If the function succeeds otherwise FALSE. To get extended error
information, call GetLastError. </p>

<p><strong>Remarks</strong></p>

<p>Queries this service to determine if this service can currently be
stopped.</p>

<p>&nbsp;</p>

<p><a name="scmsAcceptPauseContinue"></a><strong>CNTScmService::AcceptPauseContinue</strong></p>

<p><strong>BOOL AcceptPauseContinue(BOOL&amp; </strong><em>bPauseContinue</em><strong>);</strong></p>

<p><strong>Parameters</strong></p>

<p><i>bPauseContinue</i> Upon a successful return from this function,
bPauseContinue will indicate whether this service can be paused and continued. </p>

<p><strong>Return Values</strong></p>

<p>TRUE If the function succeeds otherwise FALSE. To get extended error
information, call GetLastError. </p>

<p><strong>Remarks</strong></p>

<p>Queries this service to determine if this service can currently be
paused / continued.</p>

<p>&nbsp;</p>

<p><a name="scmsAcceptShutdown"></a><strong>CNTScmService::AcceptShutdown</strong></p>

<p><strong>BOOL AcceptShutdown(BOOL&amp; </strong><em>bShutdown</em><strong>);</strong></p>

<p><strong>Parameters</strong></p>

<p><i>bShutdown</i> Upon a successful return from this function,
bShutdown will indicate whether this service handles the shutdown request. </p>

<p><strong>Return Values</strong></p>

<p>TRUE If the function succeeds otherwise FALSE. To get extended error
information, call GetLastError.</p>

<p><strong>Remarks</strong></p>

<p>Queries this service to determine if this service handles the
shutdown request.</p>

<p>&nbsp;</p>

<p><a name="scmsQueryStatus"></a><strong>CNTScmService::QueryStatus</strong></p>

<p><strong>BOOL QueryStatus(SERVICE_STATUS&amp; </strong><em>ServiceStatus</em><strong>)
const;</strong></p>

<p><b>
  BOOL QueryStatus(SERVICE_STATUS_PROCESS&amp; </b><i> ssp</i><b>) const;</b></p>

<p><strong>Parameters</strong></p>

<p><i>ServiceStatus</i> Upon a successful return from this function,
ServiceStatus will contain the current status of this service. </p>

<p><i>ssp</i> Upon a successful return from this function,
ssp will contain detailed info about the current status of this service. </p>

<p><strong>Return Values</strong></p>

<p>TRUE If the function succeeds otherwise FALSE. To get extended error
information, call GetLastError. </p>

<p><strong>Remarks</strong></p>

<p>Queries this service for its current status. The overridden
version which takes a SERVICE_STATUS_PROCESS structure is only available on
Windows 2000.</p>

<p>&nbsp;</p>

<p><a name="scmsQueryConfig"></a><strong>CNTScmService::QueryConfig</strong></p>

<p><strong>BOOL QueryConfig(LPQUERY_SERVICE_CONFIG&amp; </strong><em>lpServiceConfig</em><strong>)
const;</strong></p>

<p><strong>Parameters</strong></p>

<p><i>lpServiceConfig</i> Upon a successful return from this function,
lpServiceConfig will contain the current configuration of this service. </p>

<p><strong>Return Values</strong></p>

<p>TRUE If the function succeeds otherwise FALSE. To get extended error
information, call GetLastError. </p>

<p><strong>Remarks</strong></p>

<p>Queries this service for its current configuration. Bear in mind
that since the QUERY_SERVICE_CONFIG is a variable sized structure, internally this
function will allocate the required memory for lpServiceConfig, It is the responsibility
of the client to delete this structure. This can be done as follows:</p>

<p>LPQUERY_SERVICE_CONFIG lpConfig = NULL;<br>
service.QueryConfig(lpConfig);<br>
delete [] (BYTE*) lpConfig;</p>

<p>&nbsp;</p>

<p><a name="scmsCreate"></a><strong>CNTScmService::Create</strong></p>

<p><strong>BOOL Create(CNTServiceControlManager&amp; </strong><em>Manager</em><strong>,
LPCTSTR </strong><em>lpServiceName</em><strong>, LPCTSTR </strong><em>lpDisplayName</em><strong>,
DWORD </strong><em>dwDesiredAccess</em><strong>, DWORD </strong><em>dwServiceType</em><strong>,
DWORD </strong><em>dwStartType</em><strong>, DWORD </strong><em>dwErrorControl</em><strong>,
LPCTSTR </strong><em>lpBinaryPathName</em><strong>, LPCTSTR </strong><em>lpLoadOrderGroup</em><strong>,
LPDWORD </strong><em>lpdwTagId</em><strong>, LPCTSTR </strong><em>lpDependencies</em><strong>,
LPCTSTR </strong><em>lpServiceStartName</em><strong>, LPCTSTR </strong><em>lpPassword</em><strong>);</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call CreateService.
See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="scmsDelete"></a><strong>CNTScmService::Delete</strong></p>

<p><strong>BOOL Delete() const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call DeleteService.
See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="scmsEnumDependents"></a><strong>CNTScmService::EnumDependents</strong></p>

<p><strong>BOOL EnumDependents(DWORD </strong><em>dwServiceState</em><strong>,
DWORD </strong><em>dwUserData</em><strong>, ENUM_SERVICES_PROC </strong><em>lpEnumServicesFunc</em><strong>)
const;</strong></p>

<p><strong>Parameters</strong></p>

<p><em>dwServiceState</em> Specifies the services to enumerate based on
their running state. It must be one or both of the following values: </p>

<table cellSpacing="4" cols="2">
<TBODY>
  <tr vAlign="top">
    <th align="left" width="155">Value</th>
    <th align="left" width="292">Meaning</th>
  </tr>
  <tr vAlign="top">
    <td width="155">SERVICE_ACTIVE</td>
    <td width="292">Enumerates services that are in the following states:
    SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING, SERVICE_CONTINUE_PENDING,
    SERVICE_PAUSE_PENDING, and SERVICE_PAUSED.</td>
  </tr>
  <tr vAlign="top">
    <td width="155">SERVICE_INACTIVE</td>
    <td width="292">Enumerates services that are in the SERVICE_STOPPED
    state.</td>
  </tr>
  <tr vAlign="top">
    <td width="155">SERVICE_STATE_ALL</td>
    <td width="292">Combines the following states: SERVICE_ACTIVE and
    SERVICE_INACTIVE. </td>
  </tr>
</TBODY>
</table>

<p><em>dwUserData</em> Any user defined DWORD which you want to send to
the callback function.</p>

<p><em>lpEnumServicesFunc</em> pointer to a callback function to use to
enumerate the dependent services</p>

<p><strong>Remarks</strong></p>

<p>This function allows you to enumerate the services upon
which this service is dependent. Internally this calls EnumDependentServices and calls the
callback function for each service. The format of the callback function is:</p>

<p>BOOL CALLBACK ENUM_SERVICES_PROC(DWORD dwData,
ENUM_SERVICE_STATUS&amp; ServiceStatus);</p>

<p><em>dwData</em> This is the value as send into the
Enumeration function</p>

<p><em>ServiceStatus</em> Contains the information related to
the enumerated service. See the SDK documentation for further details.</p>

<p>Return TRUE from the function to continue enumeration and
FALSE to stop enumeration</p>

<p>&nbsp;</p>

<p><a name="scmsQueryObjectSecurity"></a><strong>CNTScmService::QueryObjectSecurity</strong></p>

<p><strong>BOOL QueryObjectSecurity(SECURITY_INFORMATION </strong><em>dwSecurityInformation</em><strong>,
PSECURITY_DESCRIPTOR&amp; </strong><em>lpSecurityDescriptor</em><strong>) const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call
QueryServiceObjectSecurity. See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="scmsSetObjectSecurity"></a><strong>CNTScmService::SetObjectSecurity</strong></p>

<p><strong>BOOL SetObjectSecurity(SECURITY_INFORMATION </strong><em>dwSecurityInformation</em><strong>,
PSECURITY_DESCRIPTOR&amp; </strong><em>lpSecurityDescriptor</em><strong>) const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call
SetServiceObjectSecurity. See the SDK for full details on this function. Bear in mind that
since the PSECURITY_DESCRIPTOR is a variable sized structure, internally this function
will allocate the required memory for lpSecurityDescriptor, It is the responsibility of
the client to delete this structure. This can be done as follows:</p>

<p>PSECURITY_DESCRIPTOR lpDescriptor = NULL;<br>
service.QueryObjectSecurity(whatever, lpDescriptor);<br>
delete [] (BYTE*) lpDescriptor;</p>

<p>&nbsp;</p>

<p><a name="QueryDescription"></a><strong>CNTScmService::QueryDescription</strong></p>

<p><strong>BOOL QueryDescription(CString&amp; </strong><i>sDescription</i><strong>) const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call
QueryServiceConfig2 using the info level SERVICE_CONFIG_DESCRIPTION. See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="QueryFailureActions"></a><strong>CNTScmService::QueryFailureActions</strong></p>

<p><b>BOOL
QueryFailureActions(LPSERVICE_FAILURE_ACTIONS&amp; </b><i> lpActions</i><b>) const;</b></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call
QueryServiceConfig2 using the info level SERVICE_CONFIG_FAILURE_ACTIONS. See the SDK for full details on this function. Bear in mind that
since the SERVICE_FAILURE_ACTIONS is a variable sized structure, internally this function
will allocate the required memory for lpActions, It is the responsibility of
the client to delete this structure. This can be done as follows:</p>

<p>LPSERVICE_FAILURE_ACTIONS lpActions = NULL;<br>
service.QueryFailureActions(lpActions);<br>
delete [] (BYTE*) lpActions;</p>

<p>&nbsp;</p>

<p><a name="ChangeDescription"></a><strong>CNTScmService::ChangeDescription</strong></p>

<p><strong>BOOL ChangeDescription(const
CString&amp; </strong><i>sDescription</i><strong>);</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call ChangeServiceConfig2
using the info level SERVICE_CONFIG_DESCRIPTION. See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="ChangeFailureActions"></a><strong>CNTScmService::ChangeFailureActions</strong></p>

<p><strong>BOOL
ChangeFailureActions(SERVICE_FAILURE_ACTIONS&amp; </strong><i>Actions</i><strong>);</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call ChangeServiceConfig2
using the info level SERVICE_CONFIG_FAILURE_ACTIONS. See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="sumCNTServiceControlManager"></a><strong>CNTServiceControlManager</strong></p>

<p>CNTServiceControlManager is a class which encapsulates a
connection to a Service Control Manager (SCM) on some machine. Functionality provided
includes enumeration, database locking and service access.</p>

<p>&nbsp;</p>

<p><strong>Functions this class provides include:</strong></p>

<p><b><a href="#CNTServiceControlManager">CNTServiceControlManager<br>
</a><a href="#~CNTServiceControlManager">~CNTServiceControlManager<br>
</a><a href="#scmHandle">operator HANDLE<br>
</a><a href="#scmAttach">Attach<br>
</a><a href="#scmDetach">Detach<br>
</a><a href="#scmOpen">Open<br>
</a><a href="#scmClose">Close<br>
</a><a href="#scmQueryLockStatus">QueryLockStatus<br>
</a><a href="#scmEnumServices">EnumServices<br>
</a><a href="#scmOpenService">OpenService<br>
</a><a href="#scmLock">Lock<br>
</a><a href="#scmUnlock">Unlock</a></b></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="CNTServiceControlManager"></a><strong>CNTServiceControlManager::CNTServiceControlManager</strong></p>

<p><strong>CNTServiceControlManager();</strong></p>

<p><strong>Remarks</strong></p>

<p>This is the default constructor which just initializes
all
internal variables to a safe state.</p>

<p><strong>See Also </strong><a href="#~CNTServiceControlManager">~CNTServiceControlManager</a></p>

<p>&nbsp;</p>

<p><a name="~CNTServiceControlManager"></a><strong>CNTServiceControlManager::~CNTServiceControlManager</strong></p>

<p><strong>~CNTServiceControlManager();</strong></p>

<p><strong>Remarks</strong></p>

<p>This is the standard destructor for the class. Internally
it will call <a href="#scmClose">Close</a> to ensure that any handle that is opened by
this instance is closed</p>

<p><strong>See Also </strong><a href="#CNTServiceControlManager">CNTServiceControlManager</a>
<a href="#scmClose">Close</a></p>

<p>&nbsp;</p>

<p><a name="scmHandle"></a><strong>CNTServiceControlManager::operator
HANDLE</strong></p>

<p><strong>operator SC_HANDLE() const;</strong></p>

<p><strong>Return Value:</strong></p>

<p>The underlying SDK service handle representing this class.</p>

<p><strong>Remarks</strong></p>

<p>This function exposes the underlying handle which the
CNTServiceControlManager class wraps. This function is provided for integration with
legacy code which uses the handle directly.</p>

<p>&nbsp;</p>

<p><a name="scmAttach"></a><strong>CNTServiceControlManager::Attach</strong></p>

<p><strong>BOOL Attach(SC_HANDLE </strong><em>hSCM</em><strong>);</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if the function was successful, otherwise FALSE. To
get extended error information, call GetLastError </p>

<p><strong>Parameters</strong></p>

<p><em>hSCM</em> An SDK service control manager handle
returned from SDK calls to the SCM APIs</p>

<p><strong>Remarks</strong></p>

<p>Use this member function to attach an existing SDK handle
to a CNTServiceControlManager.</p>

<p><strong>See Also</strong> <a href="#scmDetach">Detach</a></p>

<p>&nbsp;</p>

<p><a name="scmDetach"></a><strong>CNTServiceControlManager::Detach</strong></p>

<p><strong>SC_HANDLE Detach();</strong></p>

<p><strong>Return Value</strong></p>

<p>The SDK service control manager handle</p>

<p><strong>Remarks</strong></p>

<p>Call this function to detach m_hSCM from the
CNTServiceControlManager object and&nbsp; set m_hSCM to NULL.</p>

<p><strong>See Also</strong> <a href="#scmAttach">Attach</a></p>

<p>&nbsp;</p>

<p><a name="scmOpen"></a><strong>CNTServiceControlManager::Open</strong></p>

<p><strong>BOOL Open(LPCTSTR </strong><em>pszMachineName</em><strong>,
DWORD </strong><em>dwDesiredAccess</em><strong>);</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call OpenSCManager.
See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="scmClose"></a><strong>CNTServiceControlManager::Close</strong></p>

<p><strong>void Close();</strong></p>

<p><strong>Remarks</strong></p>

<p>This frees the SC_HANDLE by internally calling
CloseServiceHandle which this class encapsulates.</p>

<p>&nbsp;</p>

<p><a name="scmQueryLockStatus"></a><strong>CNTServiceControlManager::QueryLockStatus</strong></p>

<p><strong>BOOL
QueryLockStatus(LPQUERY_SERVICE_LOCK_STATUS&amp; </strong><em>lpLockStatus</em><strong>)
const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call
QueryServiceLockStatus. See the SDK for full details on this function. Bear in mind that
since the LPQUERY_SERVICE_LOCK_STATUS is a variable sized structure, internally this
function will allocate the required memory for lpLockStatus, It is the responsibility of
the client to delete this structure. This can be done as follows:</p>

<p>LPQUERY_SERVICE_LOCK_STATUS lpLockStatus = NULL;<br>
scm.QueryLockStatus(lpLockStatus);<br>
delete [] (BYTE*) lpLockStatus;</p>

<p>&nbsp;</p>

<p><a name="scmEnumServices"></a><strong>CNTServiceControlManager::EnumServices</strong></p>

<p><strong>BOOL EnumServices(DWORD </strong><em>dwServiceType</em><strong>,
DWORD </strong><em>dwServiceState</em><strong>, void* </strong><em>pUserData</em><strong>,
ENUM_SERVICES_PROC </strong><em>lpEnumServicesFunc</em><strong>) const;</strong></p>

<p><b>
  BOOL EnumServices(DWORD </b><i> dwServiceType</i><b>, DWORD </b><i> dwServiceState</i><b>, LPCTSTR
</b><i>
pszGroupName</i><b>,                    void* </b><i> pUserData</i><b>, ENUM_SERVICES_PROC2
</b><i> lpEnumServicesFunc</i><b>) const;</b></p>

<p><strong>Parameters</strong></p>

<p><i>dwServiceType</i> Specifies the type of services to enumerate. It
must be one or both of the following values: </p>

<table cellSpacing="4" cols="2">
<TBODY>
  <tr vAlign="top">
    <th align="left" width="154">Value</th>
    <th align="left" width="292">Meaning</th>
  </tr>
  <tr vAlign="top">
    <td width="154">SERVICE_WIN32</td>
    <td width="292">Enumerates services of type SERVICE_WIN32_OWN_PROCESS
    and SERVICE_WIN32_SHARE_PROCESS.</td>
  </tr>
  <tr vAlign="top">
    <td width="154">SERVICE_DRIVER</td>
    <td width="292">Enumerates services of type SERVICE_KERNEL_DRIVER and
    SERVICE_FILE_SYSTEM_DRIVER.</td>
  </tr>
</TBODY>
</table>

<p><i>dwServiceState</i> Specifies the services to enumerate based on
their running state. It must be one or both of the following values: </p>

<table cellSpacing="4" cols="2">
<TBODY>
  <tr vAlign="top">
    <th align="left" width="154">Value</th>
    <th align="left" width="292">Meaning</th>
  </tr>
  <tr vAlign="top">
    <td width="154">SERVICE_ACTIVE</td>
    <td width="292">Enumerates services that are in the following states:
    SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING, SERVICE_CONTINUE_PENDING,
    SERVICE_PAUSE_PENDING, and SERVICE_PAUSED.</td>
  </tr>
  <tr vAlign="top">
    <td width="154">SERVICE_INACTIVE</td>
    <td width="292">Enumerates services that are in the SERVICE_STOPPED
    state.</td>
  </tr>
  <tr vAlign="top">
    <td width="154">SERVICE_STATE_ALL</td>
    <td width="292">Combines the following states: SERVICE_ACTIVE and
    SERVICE_INACTIVE. </td>
  </tr>
</TBODY>
</table>

<p><em>pUserData</em> Any user defined void* which you want to send to
the callback function.</p>

<p><i>pszGroupName</i> Specifies a load-order group name. If
this parameter is a string, the only services enumerated are those that belong
to the group that has the name specified by the string. If this parameter is an
empty string, only services that do not belong to any group are enumerated. If
this parameter is NULL, group membership is ignored and all services are
enumerated.</p>

<p><em>lpEnumServicesFunc</em> pointer to a callback function to use to
enumerate the dependent services</p>

<p><strong>Remarks</strong></p>

<p>This function allows you to enumerate the services which
in the SCM. Internally this calls EnumServicesStatus or (EnumServicesStatusEx) and calls the callback function for
each service. The format of the callback functions are:</p>

<p>typedef BOOL CALLBACK ENUM_SERVICES_PROC(void* pData,
ENUM_SERVICE_STATUS&amp; ServiceStatus);</p>

<p>  typedef BOOL CALLBACK ENUM_SERVICES_PROC2(void* pData, ENUM_SERVICE_STATUS_PROCESS&amp; ssp);</p>

<p><em>pData</em> This is the value as send into the
enumeration function</p>

<p><em>ServiceStatus</em> Contains the information related to
the enumerated service. See the SDK documentation for further details.</p>

<p><em>ssp</em> Contains the information related to
the enumerated service. See the SDK documentation for further details.</p>

<p>Return TRUE from the function to continue enumeration and
FALSE to stop enumeration</p>

<p>&nbsp;</p>

<p><a name="scmOpenService"></a><strong>CNTServiceControlManager::OpenService</strong></p>

<p><strong>BOOL OpenService(LPCTSTR </strong><em>lpServiceName</em><strong>,
DWORD </strong><em>dwDesiredAccess</em><strong>, CNTScmService&amp; </strong><em>service</em><strong>)
const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call of the same
name. See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="scmLock"></a><strong>CNTServiceControlManager::Lock</strong></p>

<p><strong>BOOL Lock();</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call
LockServiceDatabase. See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="scmUnlock"></a><strong>CNTServiceControlManager::Unlock</strong></p>

<p><strong>BOOL Unlock();</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call
UnlockServiceDatabase. See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="sumCEventLogRecord"></a><strong>CEventLogRecord</strong></p>

<p>CEventLogRecord is a C++ wrapper class for the
EVENTLOGRECORD structure as provided in the SDK. For anyone who has had to use this class
using raw SDK calls, you will appreciate the easier access which the class provides.</p>

<p>&nbsp;</p>

<p><strong>Functions and members this class provides include:</strong></p>

<p><b><a href="#CEventLogRecord">CEventLogRecord<br>
</a><a href="#elr=">operator=<br>
</a><a href="#m_dwRecordNumber">m_dwRecordNumber<br>
</a><a href="#m_TimeGenerated">m_TimeGenerated<br>
</a><a href="#m_TimeWritten">m_TimeWritten<br>
</a><a href="#m_dwEventID">m_dwEventID<br>
</a><a href="#m_wEventTypes">m_wEventTypes<br>
</a><a href="#m_wEventCategory">m_wEventCategory<br>
</a><a href="#m_UserSID">m_UserSID<br>
</a><a href="#m_Strings">m_Strings<br>
</a><a href="#m_Data">m_Data<br>
</a><a href="#m_sSourceName">m_sSourceName<br>
</a><a href="#m_sComputerName">m_sComputerName</a></b></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="CEventLogRecord"></a><strong>CEventLogRecord::CEventLogRecord</strong></p>

<p><strong>CEventLogRecord();</strong></p>

<p><strong>CEventLogRecord(const CEventLogRecord&amp; </strong><em>record</em><strong>);</strong></p>

<p><strong>CEventLogRecord(const EVENTLOGRECORD* </strong><em>pRecord</em><strong>);</strong></p>

<p><strong>Parameters</strong></p>

<p>record An existing CEventLogRecord</p>

<p>pRecord An existing SDK EVENTLOGRECORD structure</p>

<p>&nbsp;</p>

<p><a name="elr="></a><strong>CEventLogRecord::operator=</strong></p>

<p><strong>CEventLogRecord&amp; operator=(const
CEventLogRecord&amp; </strong><em>record</em><strong>);</strong></p>

<p><strong>Remarks</strong></p>

<p>The standard copy constructor</p>

<p>&nbsp;</p>

<p><a name="m_dwRecordNumber"></a><strong>CEventLogRecord::m_dwRecordNumber</strong></p>

<p><strong>DWORD m_dwRecordNumber;</strong></p>

<p><strong>Remarks</strong></p>

<p>Contains the record number for this event log entry </p>

<p>&nbsp;</p>

<p><a name="m_TimeGenerated"></a><strong>CEventLogRecord::m_TimeGenerated</strong></p>

<p><strong>CTime m_TimeGenerated;</strong></p>

<p><strong>Remarks</strong></p>

<p>The CTime representation of when this entry was submitted.</p>

<p>&nbsp;</p>

<p><a name="m_TimeWritten"></a><strong>CEventLogRecord::m_TimeWritten</strong></p>

<p><strong>CTime m_TimeWritten;</strong></p>

<p><strong>Remarks</strong></p>

<p>The CTime representation of when this entry was written to
the event log.</p>

<p>&nbsp;</p>

<p><a name="m_dwEventID"></a><strong>CEventLogRecord::m_dwEventID</strong></p>

<p><strong>DWORD m_dwEventID;</strong></p>

<p><strong>Remarks</strong></p>

<p>Specifies the event. This is specific to the source that
generated the event log entry, and is used, together with <b>SourceName</b>, to identify a
message in a message file that is presented to the user while viewing the log.</p>

<p>&nbsp;</p>

<p><a name="m_wEventTypes"></a><strong>CEventLogRecord::m_wEventTypes</strong></p>

<p><strong>WORD m_wEventType;</strong></p>

<p><strong>Remarks</strong></p>

<p>Specifies the type of event. This member can be one of the following
values: </p>

<table cellSpacing="4" cols="2">
<TBODY>
  <tr vAlign="top">
    <th align="left" width="243">Value</th>
    <th align="left" width="222">Meaning</th>
  </tr>
  <tr vAlign="top">
    <td width="243">EVENTLOG_ERROR_TYPE</td>
    <td width="222">Error event</td>
  </tr>
  <tr vAlign="top">
    <td width="243">EVENTLOG_WARNING_TYPE</td>
    <td width="222">Warning event</td>
  </tr>
  <tr vAlign="top">
    <td width="243">EVENTLOG_INFORMATION_TYPE</td>
    <td width="222">Information event</td>
  </tr>
  <tr vAlign="top">
    <td width="243">EVENTLOG_AUDIT_SUCCESS</td>
    <td width="222">Success Audit event</td>
  </tr>
  <tr vAlign="top">
    <td width="243">EVENTLOG_AUDIT_FAILURE</td>
    <td width="222">Failure Audit event</td>
  </tr>
</TBODY>
</table>

<p>&nbsp;</p>

<p><a name="m_wEventCategory"></a><strong>CEventLogRecord::m_wEventCategory</strong></p>

<p><strong>WORD m_wEventCategory;</strong></p>

<p><strong>Remarks</strong></p>

<p>Specifies a subcategory for this event. This subcategory
is source specific. </p>

<p>&nbsp;</p>

<p><a name="m_UserSID"></a><strong>CEventLogRecord::m_UserSID</strong></p>

<p><strong>CByteArray m_UserSID;</strong></p>

<p><strong>Remarks</strong></p>

<p>A CByteArray representation of the security identifier of the active
user at the time this event was logged. </p>

<p>&nbsp;</p>

<p><a name="m_Strings"></a><strong>CEventLogRecord::m_Strings</strong></p>

<p><strong>CStringArray m_Strings;</strong></p>

<p><strong>Remarks</strong></p>

<p>A CStringArray representation of the strings which are merged into
the message before it is displayed to the user. </p>

<p>&nbsp;</p>

<p><a name="m_Data"></a><strong>CEventLogRecord::m_Data</strong></p>

<p><strong>CByteArray m_Data;</strong></p>

<p><strong>Remarks</strong></p>

<p>A CByteArray representation of the event-specific
information within this event record.</p>

<p>&nbsp;</p>

<p><a name="m_sSourceName"></a><strong>CEventLogRecord::m_sSourceName</strong></p>

<p><strong>CString m_sSourceName;</strong></p>

<p><strong>Remarks</strong></p>

<p>Contains the string specifying the name of the source
(application, service, driver, subsystem) that generated the entry.</p>

<p>&nbsp;</p>

<p><a name="m_sComputerName"></a><strong>CEventLogRecord::m_sComputerName</strong></p>

<p><strong>CString m_sComputerName;</strong></p>

<p><strong>Remarks</strong></p>

<p>Contains the string specifying the name of the computer
that generated this event.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="sumCNTEventLog"></a><strong>CNTEventLog</strong></p>

<p>CNTEventLog is a C++ wrapper class for accessing the NT
Event Logs. You can consider this as the client side to the Event Log APIs.</p>

<p>&nbsp;</p>

<p><strong>Functions this class provides include:</strong></p>

<p><b><a href="#CNTEventLog">CNTEventLog<br>
</a><a href="#~CNTEventLog">~CNTEventLog<br>
</a><a href="#elHandle">operator HANDLE<br>
</a><a href="#elAttach">Attach<br>
</a><a href="#elDetach">Detach<br>
</a><a href="#elOpen">Open<br>
</a><a href="#elOpenBackup">OpenBackup<br>
</a><a href="#elOpenApplication">OpenApplication<br>
</a><a href="#elOpenSystem">OpenSystem<br>
</a><a href="#elOpenSecurity">OpenSecurity<br>
</a><a href="#elClose">Close<br>
</a><a href="#elBackup">Backup<br>
</a><a href="#elClear">Clear<br>
</a><a href="#elGetNumberOfRecords">GetNumberOfRecords<br>
</a><a href="#elGetOldestRecord">GetOldestRecord<br>
</a><a href="#elNotifyChange">NotifyChange<br>
</a><a href="#elReadNext">ReadNext<br>
</a><a href="#elReadPrev">ReadPrev</a></b></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="CNTEventLog"></a><strong>CNTEventLog::CNTEventLog</strong></p>

<p><strong>CNTEventLog();</strong></p>

<p><strong>Remarks</strong></p>

<p>This is the default constructor which just initializes
all
internal variables to a safe state.</p>

<p><strong>See Also </strong><a href="#~CNTEventLog">~CNTEventLog</a></p>

<p>&nbsp;</p>

<p><a name="~CNTEventLog"></a><strong>CNTEventLog::~CEventLog</strong></p>

<p><strong>~CNTEventLog();</strong></p>

<p><strong>Remarks</strong></p>

<p>This is the standard destructor for the class. Internally
it will call <a href="#elClose">Close</a> to ensure that any handle that is opened by this
instance is closed</p>

<p><strong>See Also </strong><a href="#CNTEventLog">CNTEventLog</a> <a
href="#elClose">Close</a></p>

<p>&nbsp;</p>

<p><a name="elHandle"></a><strong>CNTEventLog::operator
HANDLE</strong></p>

<p><strong>operator HANDLE() const;</strong></p>

<p><strong>Return Value:</strong></p>

<p>The underlying SDK event log handle representing this
class.</p>

<p><strong>Remarks</strong></p>

<p>This function exposes the underlying handle which
CNTEventLog class wraps. This function is provided for integration with legacy code which
uses the handle directly.</p>

<p>&nbsp;</p>

<p><a name="elAttach"></a><strong>CNTEventLog::Attach</strong></p>

<p><strong>BOOL Attach(HANDLE </strong><em>hEventLog</em><strong>);</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if the function was successful, otherwise FALSE. To
get extended error information, call GetLastError </p>

<p><strong>Parameters</strong></p>

<p><em>hEventLog</em> An SDK event log handle returned from
SDK calls to the Event log APIs</p>

<p><strong>Remarks</strong></p>

<p>Use this member function to attach an existing SDK handle
to a CNTEventLog.</p>

<p><strong>See Also</strong> <a href="#elDetach">Detach</a></p>

<p>&nbsp;</p>

<p><a name="elDetach"></a><strong>CNTEventLog::Detach</strong></p>

<p><strong>HANDLE Detach();</strong></p>

<p><strong>Return Value</strong></p>

<p>The SDK event log handle</p>

<p><strong>Remarks</strong></p>

<p>Call this function to detach m_hEventLog from the
CNTEventLog object and&nbsp; set m_hEventLog to NULL.</p>

<p><strong>See Also</strong> <a href="#elAttach">Attach</a></p>

<p>&nbsp;</p>

<p><a name="elOpen"></a><strong>CNTEventLog::Open</strong></p>

<p><strong>BOOL Open(LPCTSTR </strong><em>lpUNCServerName</em><strong>,
LPCTSTR </strong><em>lpSourceName</em><strong>);</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call OpenEventLog.
See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="elOpenBackup"></a><strong>CNTEventLog::OpenBackup</strong></p>

<p><strong>BOOL OpenBackup(LPCTSTR </strong><em>lpUNCServerName</em><strong>,
LPCTSTR </strong><em>lpFileName</em><strong>);</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call
OpenBackupEventLog. See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="elOpenApplication"></a><strong>CNTEventLog::OpenApplication</strong></p>

<p><strong>BOOL OpenApplication(LPCTSTR </strong><em>lpUNCServerName</em><strong>);</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a sample wrapper for opening the
&quot;Application&quot; event log on the specified computer, Internally it just calls <a
href="#elOpen">Open</a> with the appropriate string &quot;Application&quot;.</p>

<p>&nbsp;</p>

<p><a name="elOpenSystem"></a><strong>CNTEventLog::OpenSystem</strong></p>

<p><strong>BOOL OpenSystem(LPCTSTR </strong><em>lpUNCServerName</em><strong>);</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a sample wrapper for opening the
&quot;system&quot; event log on the specified computer, Internally it just calls <a
href="#elOpen">Open</a> with the appropriate string &quot;System&quot;.</p>

<p>&nbsp;</p>

<p><a name="elOpenSecurity"></a><strong>CNTEventLog::OpenSecurity</strong></p>

<p><strong>BOOL OpenSecurity(LPCTSTR </strong><em>lpUNCServerName</em><strong>);</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a sample wrapper for opening the
&quot;Security&quot; event log on the specified computer, Internally it just calls <a
href="#elOpen">Open</a> with the appropriate string &quot;Security&quot;.</p>

<p>&nbsp;</p>

<p><a name="elClose"></a><strong>CNTEventLog::Close</strong></p>

<p><strong>BOOL Close();</strong></p>

<p><strong>Remarks</strong></p>

<p>This frees the HANDLE by internally calling CloseEventLog
which this class encapsulates.</p>

<p>&nbsp;</p>

<p><a name="elBackup"></a><strong>CNTEventLog::Backup</strong></p>

<p><strong>BOOL Backup(LPCTSTR </strong><em>lpBackupFileName</em><strong>)
const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call BackupeventLog.
See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="elClear"></a><strong>CNTEventLog::Clear</strong></p>

<p><strong>BOOL Clear(LPCTSTR </strong><em>lpBackupFileName</em><strong>)
const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call ClearEventLog.
See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="elGetNumberOfRecords"></a><strong>CNTEventLog::GetNumberOfRecords</strong></p>

<p><strong>BOOL GetNumberOfRecords(DWORD&amp; </strong><em>dwNumberOfRecords</em><strong>)
const;</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if the function was successful, otherwise FALSE. To
get extended error information, call GetLastError </p>

<p><strong>Parameters</strong></p>

<p><em>dwNumberOfRecords</em> Upon successful return this
will contain the number of records in the event log.</p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call
GetNumberOfEventLogRecords. See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="elGetOldestRecord"></a><strong>CNTEventLog::GetOldestRecord</strong></p>

<p><strong>BOOL GetOldestRecord(DWORD&amp; </strong><em>dwOldestRecord</em><strong>)
const;</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if the function was successful, otherwise FALSE. To
get extended error information, call GetLastError </p>

<p><strong>Parameters</strong></p>

<p><em>dwOldestRecord</em> Upon successful return this will
contain the record number of the oldest record in the event log.</p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call
GetOldestEventLogRecord. See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="elNotifyChange"></a><strong>CNTEventLog::NotifyChange</strong></p>

<p><strong>BOOL NotifyChange(HANDLE </strong><em>hEvent</em><strong>)
const;</strong></p>

<p><strong>Remarks</strong></p>

<p>This is a simple wrapper for the SDK call
NotifyChangeEventLog. See the SDK for full details on this function.</p>

<p>&nbsp;</p>

<p><a name="elReadNext"></a><strong>CNTEventLog::ReadNext</strong></p>

<p><strong>BOOL ReadNext(CEventLogRecord&amp; </strong><em>record</em><strong>)
const;</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if the function was successful, otherwise FALSE. To
get extended error information, call GetLastError </p>

<p><strong>Parameters</strong></p>

<p><em>record</em> Upon successful return this will contain
the next record in the event log</p>

<p><strong>Remarks</strong></p>

<p>Reads the next record in forward chronological order from
the event log. When this function returns successfully, the read position is incremented
by one ready for the next read to occur.</p>

<p>&nbsp;</p>

<p><a name="elReadPrev"></a><strong>CNTEventLog::ReadPrev</strong></p>

<p><strong>BOOL ReadPrev(CEventLogRecord&amp; </strong><em>record</em><strong>)
const;</strong></p>

<p><strong>Return Value</strong></p>

<p>TRUE if the function was successful, otherwise FALSE. To
get extended error information, call GetLastError </p>

<p><strong>Parameters</strong></p>

<p><em>record</em> Upon successful return this will contain
the previous record in the event log</p>

<p><strong>Remarks</strong></p>

<p>Reads the next record in reverse chronological order from
the event log. When this function returns successfully, the read position is decremented
by one ready for the next read to occur.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="Enhancements"></a><strong>PLANNED
ENHANCEMENTS</strong> 

<ul>
  <li>If you have any suggested improvements,
    please let me know so that I can incorporate them into the next release.</li>
</ul>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="References"></a><strong>References</strong>

<ul>
  <li>&quot;Creating a Simple Windows NT Service in C++&quot; by Nigel
    Thompson on the MSDN.</li>
  <li>The book &quot;Professional NT Services&quot; by Kevin
    Miller.</li>
  <li><a
    href="http://ourworld.compuserve.com/homepages/Sam_Blackburn/wfc.htm">Win32 Foundation
    Classes </a>developed by Sam Blackburn</li>
  <li>For detailed information on how to integrate mc files 
  into Visual Studio, please see the CodeProject article
  <a href="http://www.codeproject.com/useritems/MCTutorial.asp">
  http://www.codeproject.com/useritems/MCTutorial.asp</a>.</li>
  <li>There are numerous articles in the Platform SDK which anyone
    contemplating writing a service should read. Areas covered include: Writing to the NT
    Event Log, Reading from the Event Log, How a simple C/SDK style service is structured, the
    Service Control Manager (SCM), reporting your status back to the SCM, using
    the message compiler (MC), debugging NT Services etc etc.</li>
</ul>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="Contact"></a><strong>CONTACTING
THE AUTHOR</strong></p>

<p>PJ Naughter<br>
Email: <a href="mailto:pjna@naughter.com">pjna@naughter.com</a><br>
Web: <a href="http://www.naughter.com">http://www.naughter.com</a><br>
13 January 2006</p>
</body>
</html>